最新书签教程 链接: https://pan.baidu.com/s/1Qmbrff5ptamPexy4pEMT-Q 提取码: jsfh 在线转pdf功能，生成的pdf会自动加载书签

第一部分 基础篇 2
第1章 软件交付的问题 2
1.1引言 2
1.2一些常见的发布反模式 3
1.2.1反模式：手工部署软件 4
1.2.2反模式：开发完成之后才向类生产环境部署 5
1.2.3反模式：生产环境的手工配置管理 7
1.2.4我们能做得更好吗 8
1.3如何实现目标 9
1.3.1每次修改都应该触发反馈流程 10
1.3.2必须尽快接收反馈 11
1.3.3交付团队必须接收反馈并作出反应 12
1.3.4这个流程可以推广吗 12
1.4收效 12
1.4.1授权团队 13
1.4.2减少错误 13
1.4.3缓解压力 15
1.4.4部署的灵活性 16
1.4.5多加练习，使其完美 17
1.5候选发布版本 17
1.6软件交付的原则 19
1.6.1为软件的发布创建一个可重复且可靠的过程 19
1.6.2将几乎所有事情自动化 19
1.6.3把所有的东西都纳入版本控制 20
1.6.4提前并频繁地做让你感到痛苦的事 20
1.6.5内建质量 21
1.6.6“DONE”意味着“已发布” 21
1.6.7交付过程是每个成员的责任 22
1.6.8持续改进 22
1.7小结 23
第2章 配置管理 24
2.1引言 24
2.2使用版本控制 25
2.2.1对所有内容进行版本控制 26
2.2.2频繁提交代码到主干 28
2.2.3使用意义明显的提交注释 29
2.3依赖管理 30
2.3.1外部库文件管理 30
2.3.2组件管理 30
2.4软件配置管理 31
2.4.1配置与灵活性 31
2.4.2配置的分类 33
2.4.3应用程序的配置管理 33
2.4.4跨应用的配置管理 36
2.4.5管理配置信息的原则 37
2.5环境管理 38
2.5.1环境管理的工具 41
2.5.2变更过程管理 41
2.6小结 42
第3章 持续集成 43
3.1引言 43
3.2实现持续集成 44
3.2.1准备工作 44
3.2.2一个基本的持续集成系统 45
3.3持续集成的前提条件 46
3.3.1频繁提交 46
3.3.2创建全面的自动化测试套件 47
3.3.3保持较短的构建和测试过程 47
3.3.4管理开发工作区 49
3.4使用持续集成软件 49
3.4.1基本操作 49
3.4.2铃声和口哨 50
3.5必不可少的实践 52
3.5.1构建失败之后不要提交新代码 52
3.5.2提交前在本地运行所有的提交测试，或者让持续集成服务器完成此事 53
3.5.3等提交测试通过后再继续工作 54
3.5.4回家之前，构建必须处于成功状态 54
3.5.5时刻准备着回滚到前一个版本 55
3.5.6在回滚之前要规定一个修复时间 56
3.5.7不要将失败的测试注释掉 56
3.5.8为自己导致的问题负责 56
3.5.9测试驱动的开发 57
3.6推荐的实践 57
3.6.1极限编程开发实践 57
3.6.2若违背架构原则，就让构建失败 58
3.6.3若测试运行变慢，就让构建失败 58
3.6.4若有编译警告或代码风格问题，就让浏试失败 59
3.7分布式团队 60
3.7.1对流程的影响 60
3.7.2集中式持续集成 61
3.7.3技术问题 61
3.7.4替代方法 62
3.8分布式版本控制系统 63
3.9小结 66
第4章 测试策略的实现 67
4.1引言 67
4.2 测试的分类 68
4.2.1业务导向且支持开发过程的测试 69
4.2.2技术导向且支持开发过程的测试 72
4.2.3业务导向且评价项目的测试 72
4.2.4技术导向且评价项目的测试 73
4.2.5 测试替身 74
4.3现实中的情况与应对策略 75
4.3.1新项目 75
4.3.2项目进行中 76
4.3.3遗留系统 77
4.3.4集成测试 78
4.4流程 80
4.5小结 82
第二部分部署流水线 84
第5章 部署流水线解析 84
5.1引言 84
5.2什么是部署流水线 85
5.3部署流水线的相关实践 91
5.3.1只生成一次二进制包 91
5.3.2对不同环境采用同一部署方式 93
5.3.3对部署进行冒烟测试 94
5.3.4向生产环境的副本中部署 94
5.3.5每次变更都要立即在流水线中传递 95
5.3.6只要有环节失败，就停止整个流水线 96
5.4提交阶段 96
5.5自动化验收测试之门 99
5.6后续的测试阶段 102
5.6.1手工测试 103
5.6.2非功能测试 103
5.7发布准备 104
5.7.1自动部署与发布 104
5.7.2变更的撤销 106
5.7.3在成功的基础上构建 107
5.8实现一个部署流水线 107
5.8.1对价值流进行建模并创建简单的可工作框架 107
5.8.2构建和部署过程的自动化 108
5.8.3自动化单元测试和代码分析 109
5.8.4自动化验收测试 109
5.8.5部署流水线的演进 110
5.9度量 111
5.10小结 113
第6章 构建与部署的脚本化 115
6.1引言 115
6.2构建工具概览 116
6.2.1 Make 118
6.2.2 Ant 118
6.2.3 NAnt与MSBuild 119
6.2.4 Maven 120
6.2.5 Rake 121
6.2.6 Buildr 121
6.2.7 Psakc 121
6.3构建部署脚本化的原则与实践 122
6.3.1为部署流水线的每个阶段创建脚本 122
6.3.2使用恰当的技术部署应用程序 122
6.3.3使用同样的脚本向所有环境部署 123
6.3.4使用操作系统自带的包管理工具 124
6.3.5确保部署流程是幂等的（Idempotent） 125
6.3.6部署系统的增量式演进 126
6.4面向JVM的应用程序的项目结构 126
6.5部署脚本化 129
6.5.1多层的部署和测试 130
6.5.2测试环境配置 131
6.6小贴士 132
6.6.1总是使用相对路径 132
6.6.2消除手工步骤 132
6.6.3从二进制包到版本控制库的内建可追溯性 133
6.6.4不要把二进制包作为构建的一部分放到版本控制库中 133
6.6.5“test”不应该让构建失败 134
6.6.6用集成冒烟测试来限制应用程序 134
6.6.7NET小贴士 135
6.7小结 135
第7章 提交阶段 137
7.1引言 137
7.2提交阶段的原则和实践 138
7.2.1提供快速有用的反馈 138
7.2.2何时令提交阶段失败 139
7.2.3精心对待提交阶段 140
7.2.4让开发人员也拥有所有权 140
7.2.5在超大项目团队中指定一个构建负责人 141
7.3提交阶段的结果 141
7.4提交测试套件的原则与实践 144
7.4.1避免用户界面 145
7.4.2使用依赖注入 145
7.4.3避免使用数据库 145
7.4.4在单元测试中避免异步 146
7.4.5使用测试替身 146
7.4.6最少化测试中的状态 149
7.4.7时间的伪装 150
7.4.8蛮力 150
7.5小结 151
第8章 自动化验收测试 152
8.1引言 152
8.2为什么验收测试是至关重要的 153
8.2.1如何创建可维护的验收测试套件 155
8.2.2 GUI上的测试 156
8.3创建验收测试 157
8.3.1分析人员和测试人员的角色 157
8.3.2迭代开发项目中的分析工作 157
8.3.3将验收条件变成可执行的规格说明书 158
8.4应用程序驱动层 161
8.4.1如何表述验收条件 163
8.4.2窗口驱动器模式：让测试与GUI解耦 164
8.5实现验收测试 166
8.5.1验收测试中的状态 166
8.5.2过程边界、封装和测试 168
8.5.3管理异步与超时问题 169
8.5.4使用测试替身对象 171
8.6验收测试阶段 174
8.6.1确保验收测试一直处于通过状态 175
8.6.2部署测试 177
8.7验收测试的性能 178
8.7.1重构通用任务 178
8.7.2共享昂贵资源 179
8.7.3并行测试 180
8.7.4使用计算网格 180
8.8小结 181
第9章 非功能需求的测试 183
9.1引言 183
9.2非功能需求的管理 184
9.3如何为容量编程 186
9.4容量度量 188
9.5容量测试环境 191
9.6自动化容量测试 194
9.6.1通过UI的容量测试 195
9.6.2基于服务或公共API来录制交互操作 196
9.6.3使用录制的交互模板 197
9.6.4使用容量测试桩开发测试 198
9.7将容量测试加入到部署流水线中 199
9.8容量测试系统的附加价值 201
9.9小结 202
第10章 应用程序的部署与发布 203
10.1引言 203
10.2创建发布策略 204
10.2.1发布计划 205
10.2.2发布产品 205
10.3应用程序的部署和晋级 206
10.3.1首次部署 206
10.3.2对发布过程进行建模并让构建晋级 207
10.3.3配置的晋级 209
10.3.4联合环境 209
10.3.5部署到试运行环境 210
10.4部署回滚和零停机发布 211
10.4.1通过重新部署原有的正常版本来进行回滚 211
10.4.2零停机发布 212
10.4.3蓝绿部署 212
10.4.4金丝雀发布 213
10.5紧急修复 216
10.6持续部署 216
10.7小贴士和窍门 219
10.7.1真正执行部署操作的人应该参与部署过程的创建 219
10.7.2记录部署活动 220
10.7.3不要删除旧文件，而是移动到别的位置 220
10.7.4部署是整个团队的责任 220
10.7.5服务器应用程序不应该有GUI 220
10.7.6为新部署留预热期 221
10.7.7快速失败 221
10.7.8不要直接对生产环境进行修改 222
10.8小结 222
第三部分 交付生态圈 224
第11章 基础设施和环境管理 224
11.1 引言 224
11.2理解运维团队的需要 225
11.2.1文档与审计 226
11.2.2异常事件的告警 227
11.2.3保障IT服务持续性的计划 227
11.2.4使用运维团队熟悉的技术 228
11.3基础设施的建模和管理 229
11.3.1基础设施的访问控制 230
11.3.2对基础设施进行修改 231
11.4服务器的准备及其配置的管理 232
11.4.1服务器的准备 233
11.4.2服务器的持续管理 234
11.5中间件的配置管理 239
11.5.1管理配置项 239
11.5.2产品研究 241
11.5.3考查中间件是如何处理状态的 242
11.5.4查找用于配置的API 242
11.5.5使用更好的技术 243
11.6基础设施服务的管理 243
11.7虚拟化 245
11.7.1虚拟环境的管理 247
11.7.2虚拟环境和部署流水线 249
11.7.3用虚拟环境做高度的并行测试 251
11.8云计算 252
11.8.1云中基础设施 253
11.8.2云中平台 254
11.8.3没有普适存在 255
11.8.4对云计算的批评 256
11.9基础设施和应用程序的监控 256
11.9.1收集数据 257
11.9.2记录日志 259
11.9.3建立信息展示板 259
11.9.4行为驱动的监控 261
11.10小结 261
第12章 数据管理 263
12.1引言 263
12.2数据库脚本化 264
12.3增量式修改 265
12.3.1对数据库进行版本控制 265
12.3.2联合环境中的变更管理 267
12.4数据库回滚和无停机发布 268
12.4.1保留数据的回滚 268
12.4.2将应用程序部署与数据库迁移解耦 269
12.5测试数据的管理 270
12.5.1为单元测试进行数据库模拟 271
12.5.2管理测试与数据之间的耦合 272
12.5.3测试独立性 272
12.5.4建立和销毁 273
12.5.5连贯的测试场景 273
12.6数据管理和部署流水线 274
12.6.1提交阶段的测试数据 274
12.6.2验收测试中的数据 275
12.6.3容量测试的数据 276
12.6.4其他测试阶段的数据 277
12.7小结 278
第13章 组件和依赖管理 280
13.1 引言 280
13.2保持应用程序可发布 281
13.2.1将新功能隐蔽起来，直到它完成为止 282
13.2.2所有修改都是增量式的 283
13.2.3通过抽象来模拟分支 284
13.3依赖 285
13.3.1依赖地狱 286
13.3.2库管理 287
13.4组件 289
13.4.1如何将代码库分成多个组件 289
13.4.2将组件流水线化 292
13.4.3集成流水线 293
13.5管理依赖关系图 295
13.5.1构建依赖图 295
13.5.2为依赖图建立流水线 297
13.5.3什么时候要触发构建 299
13.5.4谨慎乐观主义 300
13.5.5循环依赖 302
13.6管理二进制包 303
13.6.1制品库是如何运作的 303
13.6.2部署流水线如何与制品库相结合 304
13.7用Maven管理依赖 304
13.8小结 308
第14章 版本控制进阶 309
14.1引言 309
14.2版本控制的历史 310
14.2.1 CVS 310
14.2.2 SVN 311
14.2.3商业版本控制系统 312
14.2.4放弃悲观锁 313
14.3分支与合并 314
14.3.1合并 316
14.3.2分支、流和持续集成 317
14.4 DVCS 319
14.4.1什么是D VCS 319
14.4.2 DVCS简史 321
14.4.3企业环境中的DVCS 321
14.4.4使用DVCS 322
14.5基于流的版本控制系统 324
14.5.1什么是基于流的版本控制系统 324
14.5.2使用流的开发模型 326
14.5.3静态视图和动态视图 327
14.5.4使用基于流的版本控制系统做持续集成 328
14.6主干开发 329
14.7按发布创建分支 332
14.8按功能特性分支 333
14.9按团队分支 335
14.10小结 338
第15章 持续交付管理 340
15.1引言 340
15.2配置与发布管理成熟度模型 341
15.3项目生命周期 343
15.3.1识别阶段 344
15.3.2启动阶段 345
15.3.3初始阶段 346
15.3.4开发与发布 347
15.3.5运营阶段 349
15.4风险管理流程 350
15.4.1风险管理基础篇 350
15.4.2风险管理时间 351
15.4.3如何做风险管理的练习 352
15.5常见的交付问题、症状和原因 353
15.5.1不频繁的或充满缺陷的部署 353
15.5.2较差的应用程序质量 354
15.5.3缺乏管理的持续集成工作流程 355
15.5.4较差的配置管理 355
15.6符合度与审计 356
15.6.1文档自动化 356
15.6.2加强可跟踪性 357
15.6.3在筒仓中工作 358
15.6.4变更管理 358
15.7小结 360
参考书目 361