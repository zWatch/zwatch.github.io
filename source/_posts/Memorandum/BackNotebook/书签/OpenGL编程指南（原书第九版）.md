封面	-17
书名	-16
版权	-15
前言	-14
目录	-6
第1章  OpenGL概述	1
	1.1  什么是OpenGL	1
	1.2  初识OpenGL程序	2
	1.3  OpenGL语法	6
	1.4  OpenGL渲染管线	7
	1.4.1  准备向OpenGL传输数据	8
	1.4.2  将数据传输到OpenGL	8
	1.4.3  顶点着色	9
	1.4.4  细分着色	9
	1.4.5  几何着色	9
	1.4.6  图元装配	9
	1.4.7  剪切	9
	1.4.8  光栅化	9
	1.4.9  片元着色	10
	1.4.10  逐片元的操作	10
	1.5  第一个程序：深入分析	11
	1.5.1  进入main（）函数	11
	1.5.2  OpenGL的初始化过程	12
	1.5.3  第一次使用OpenGL进行渲染	21
第2章  着色器基础	24
	2.1  着色器与OpenGL	25
	2.2  OpenGL的可编程管线	25
	2.3  OpenGL着色语言概述	27
	2.3.1  使用GLSL构建着色器	27
	2.3.2  存储限制符	33
	2.3.3  语句	36
	2.3.4  计算的不变性	40
	2.3.5  着色器的预处理器	42
	2.3.6  编译器的控制	44
	2.3.7  全局着色器编译选项	44
	2.4  数据块接口	45
	2.4.1  uniform块	45
	2.4.2  指定着色器中的uniform块	46
	2.4.3  从应用程序中访问uniform块	47
	2.4.4  buffer块	53
	2.4.5  in/out块、位置和分量	53
	2.5  着色器的编译	54
	2.6  着色器子程序	59
	2.6.1  GLSL的子程序设置	59
	2.6.2  选择着色器子程序	60
	2.7  独立的着色器对象	62
	2.8  SPIR-V	64
	2.8.1  选择SPIR-V的理由	64
	2.8.2  SPIR-V与OpenGL	66
	2.8.3  使用GLSL在OpenGL中生成SPIR-V	67
	2.8.4  Glslang	69
	2.8.5  SPIR-V中包含了什么	69
第3章  OpenGL绘制方式	70
	3.1  OpenGL图元	70
	3.1.1  点	71
	3.1.2  线、条带与循环线	72
	3.1.3  三角形、条带与扇面	72
	3.2  OpenGL缓存数据	75
	3.2.1  创建与分配缓存	75
	3.2.2  向缓存输入和输出数据	77
	3.2.3  访问缓存的内容	81
	3.2.4  丢弃缓存数据	86
	3.3  顶点规范	86
	3.3.1  深入讨论VertexAttribPointer	87
	3.3.2  静态顶点属性的规范	90
	3.4  OpenGL的绘制命令	92
	3.4.1  图元的重启动	99
	3.4.2  多实例渲染	102
第4章  颜色、像素和片元	112
	4.1  基本颜色理论	113
	4.2  缓存及其用途	114
	4.2.1  缓存的清除	116
	4.2.2  缓存的掩码	117
	4.3  颜色与OpenGL	118
	4.3.1  颜色的表达与OpenGL	118
	4.3.2  平滑数据插值	119
	4.4  片元的测试与操作	121
	4.4.1  剪切测试	122
	4.4.2  多重采样的片元操作	123
	4.4.3  模板测试	124
	4.4.4  模板的例子	125
	4.4.5  深度测试	127
	4.4.6  融混	129
	4.4.7  逻辑操作	133
	4.4.8  遮挡查询	134
	4.4.9  条件渲染	138
	4.5  多重采样	139
	4.6  逐图元的反走样	141
	4.6.1  线段的反走样	142
	4.6.2  多边形的反走样	143
	4.7  像素数据的读取和拷贝	143
	4.8  拷贝像素矩形	145
第5章  视口变换、裁减、剪切与反馈	147
	5.1  观察视图	148
	5.1.1  视图模型	148
	5.1.2  相机模型	148
	5.1.3  正交视图模型	151
	5.2  用户变换	152
	5.2.1  矩阵乘法的回顾	153
	5.2.2  齐次坐标	155
	5.2.3  线性变换与矩阵	157
	5.2.4  法线变换	167
	5.2.5  OpenGL矩阵	168
	5.3  OpenGL变换	170
	5.3.1  高级技巧：用户裁减和剪切	172
	5.3.2  OpenGL变换的控制	173
	5.4  transform feedback	174
	5.4.1  transform feedback对象	175
	5.4.2  transform feedback缓存	176
	5.4.3  配置transform feedback的变量	179
	5.4.4  transform feedback的启动和停止	185
	5.4.5  transform feedback的示例：粒子系统	187
第6章  纹理与帧缓存	192
	6.1  纹理综述	193
	6.2  基本纹理类型	194
	6.3  创建并初始化纹理	195
	6.4  指定纹理数据	200
	6.4.1  显式设置纹理数据	200
	6.4.2  从缓存中加载纹理	202
	6.4.3  从文件加载图像	203
	6.4.4  获取纹理数据	206
	6.4.5  纹理数据的排列布局	207
	6.5  纹理格式	211
	6.5.1  内部格式	211
	6.5.2  外部格式	214
	6.6  压缩纹理	216
	6.7  采样器对象	218
	6.8  纹理的使用	220
	6.8.1  纹理坐标	222
	6.8.2  排列纹理数据	225
	6.8.3  使用多重纹理	227
	6.9  复杂纹理类型	229
	6.9.1  3D纹理	229
	6.9.2  纹理数组	230
	6.9.3  立方体映射纹理	231
	6.9.4  阴影采样器	236
	6.9.5  深度-模板纹理	237
	6.9.6  缓存纹理	238
	6.10  纹理视图	240
	6.11  滤波方式	243
	6.11.1  线性滤波	243
	6.11.2  使用和生成mipmap	245
	6.11.3  计算mipmap层次	249
	6.11.4  mipmap细节层次的控制	250
	6.12  高级纹理查询函数	250
	6.12.1  显式的细节层次控制	250
	6.12.2  显式的梯度设置	251
	6.12.3  带有偏移参数的纹理获取函数	251
	6.12.4  投影纹理	252
	6.12.5  在着色器中执行纹理查询	253
	6.12.6  纹素收集	255
	6.12.7  组合功能的特殊函数	255
	6.13  无绑定纹理	256
	6.13.1  纹理句柄	256
	6.13.2  纹理驻留	257
	6.13.3  采样无绑定纹理	258
	6.14  稀疏纹理	259
	6.14.1  稀疏纹理的数据提交	259
	6.14.2  稀疏纹理的页面	260
	6.15  点精灵	261
	6.15.1  纹理点精灵	261
	6.15.2  控制点的显示	263
	6.16  帧缓存对象	264
	6.17  渲染到纹理贴图	266
	6.17.1  抛弃渲染数据	268
	6.17.2  渲染缓存	269
	6.17.3  创建渲染缓存的存储空间	270
	6.17.4  帧缓存附件	272
	6.17.5  帧缓存的完整性	274
	6.17.6  帧缓存的无效化	275
	6.17.7  多重渲染缓存的同步写入	276
	6.17.8  选择颜色缓存来进行读写操作	277
	6.17.9  双源融混	279
	6.18  本章总结	281
	6.18.1  纹理回顾	281
	6.18.2  纹理的最佳实践	281
第7章  光照与阴影	283
	7.1  光照介绍	284
	7.2  经典光照模型	284
	7.2.1  不同光源类型的片元着色器	285
	7.2.2  将计算移到顶点着色器	294
	7.2.3  多个光源和材质	296
	7.2.4  光照坐标系统	302
	7.2.5  经典光照模型的局限	302
	7.3  光照模型进阶	303
	7.3.1  半球光照	303
	7.3.2  基于图像的光照	306
	7.3.3  球面光照	310
	7.4  阴影映射	313
	7.4.1  创建一张阴影贴图	314
	7.4.2  使用阴影贴图	316
第8章  程序式纹理	320
	8.1  程序式纹理	321
	8.1.1  规则的花纹	322
	8.1.2  玩具球	328
	8.1.3  晶格	335
	8.1.4  程序式着色方法的总结	336
	8.2  凹凸贴图映射	336
	8.2.1  应用程序设置	338
	8.2.2  顶点着色器	340
	8.2.3  片元着色器	341
	8.2.4  法线贴图	343
	8.3  程序式纹理的反走样	343
	8.3.1  走样的来源	344
	8.3.2  避免走样问题	345
	8.3.3  提高分辨率	346
	8.3.4  高频率的反走样	347
	8.3.5  频率截断	354
	8.3.6  程序式反走样的总结	356
	8.4  噪声	356
	8.4.1  噪声的定义	358
	8.4.2  噪声纹理	362
	8.4.3  权衡	365
	8.4.4  一个简单的噪声着色器	366
	8.4.5  湍流	368
	8.4.6  大理石	369
	8.4.7  花岗岩	370
	8.4.8  木纹	370
	8.4.9  噪声的总结	373
	8.5  更多信息	373
第9章  细分着色器	375
	9.1  细分着色器	375
	9.2  细分面片	376
	9.3  细分控制着色器	377
	9.3.1  生成输出面片的顶点	378
	9.3.2  细分控制着色器的变量	378
	9.3.3  细分的控制	379
	9.4  细分计算着色器	383
	9.4.1  设置图元生成域	384
	9.4.2  设置生成图元的面朝向	384
	9.4.3  设置细分坐标的间隔	384
	9.4.4  更多的细分计算着色器layout选项	384
	9.4.5  设置顶点的位置	385
	9.4.6  细分计算着色器的变量	385
	9.5  细分实例：茶壶	386
	9.5.1  处理面片输入顶点	386
	9.5.2  计算茶壶的细分坐标	387
	9.6  更多的细分技术	389
	9.6.1  视口相关的细分	389
	9.6.2  细分的共享边与裂缝	391
	9.6.3  置换贴图映射	392
第10章  几何着色器	393
	10.1  创建几何着色器	394
	10.2  几何着色器的输入和输出	396
	10.2.1  几何着色器的输入	396
	10.2.2  特殊的几何着色器图元	399
	10.2.3  几何着色器的输出	403
	10.3  产生图元	405
	10.3.1  几何体的裁减	405
	10.3.2  几何体的扩充	406
	10.4  transform feedback高级篇	410
	10.4.1  多重输出流	411
	10.4.2  图元查询	414
	10.4.3  使用transform feedback的结果	416
	10.5  几何着色器的多实例化	423
	10.6  多视口与分层渲染	425
	10.6.1  视口索引	425
	10.6.2  分层渲染	429
	10.7  本章总结	432
	10.7.1  几何着色器回顾	433
	10.7.2  几何着色器的最佳实践	433
第11章  内存	435
	11.1  使用纹理存储通用数据	436
	11.1.1  将纹理绑定到图像单元	440
	11.1.2  图像数据的读取和写入	441
	11.2  着色器存储缓存对象	445
	11.3  原子操作和同步	446
	11.3.1  图像的原子操作	446
	11.3.2  缓存的原子操作	454
	11.3.3  同步对象	455
	11.3.4  图像限定符和屏障	459
	11.3.5  高性能的原子计数器	467
	11.4  示例：顺序无关的透明	470
	11.4.1  工作原理	471
	11.4.2  初始化	472
	11.4.3  渲染	473
	11.4.4  排序和融混	477
	11.4.5  结果	480
第12章  计算着色器	481
	12.1  概述	481
	12.2  工作组及其执行	482
	12.3  通信与同步	487
	12.3.1  通信	488
	12.3.2  同步	489
	12.4  示例	490
	12.4.1  物理模拟	491
	12.4.2  图像处理	496
	12.5  本章总结	500
	12.5.1  计算着色器回顾	500
	12.5.2  计算着色器的最佳实践	500
	附录A  第三方支持库	502
	附录B  OpenGL ES与WebGL	514
	附录C  内置GLSL变量与函数	525
	附录D  状态变量	576
	附录E  齐次坐标与变换矩阵	620
	附录F  纹理、帧缓存与渲染缓存的浮点格式	625
	附录G  OpenGL程序的调试与优化	631
	附录H  缓存对象的布局	645
	术语表	648
封底	665
