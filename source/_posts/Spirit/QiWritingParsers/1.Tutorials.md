## 快速开始Quick Start

> 您为什么要使用Spirit.Qi？

Spirit.Qi被设计为实用的解析工具。 从用C ++内联的正式EBNF规范生成完整的解析器的能力大大减少了开发时间。 程序员通常使用带有原始工具（如scanf）的即席hack进行解析。 当我们需要编写更复杂的解析器时，即使是正则表达式库（例如boost regex）或扫描器（例如Boost tokenizer）也无法很好地扩展。 尝试使用这些工具编写甚至复杂程度适中的解析器也会导致难以理解和维护的代码。

一个主要目的是使该工具易于使用。 当人们想到解析器生成器时，通常的反应是“它必须庞大且复杂，学习曲线陡峭。” 不是这样 Spirit被设计为完全可扩展的。 该库是分层结构的。 仅需学习最少的核心和基本概念，即可根据需要进行学习。

为了简化开发并简化部署，整个库仅包含头文件，没有链接或构建的库。 只需将Spirit发行版放入您的include路径，进行编译和运行即可。 代码大小？ -非常严格-本质上与手写递归下降码相当。

我们的教程将引导您完成最简单的Spirit示例，并随着我们提供越来越多的功能和技术而逐步建立在较早的示例之上。 我们将努力使学习曲线尽可能柔和。 我们将以菜谱风格介绍这些教程。 这种演示风格基于我们的BoostCon '07和BoostCon '08幻灯片。

玩得开心！

## 热身[Warming up](https://www.boost.org/doc/libs/1_73_0/libs/spirit/doc/html/spirit/qi/tutorials/warming_up.html)

我们将首先显示解析器表达式的示例，以使您了解如何从最简单的解析器构建解析器，并逐步构建。 当将EBNF与Spirit进行比较时，这些表达起初似乎有些尴尬。 Spirit大量使用运算符重载来实现其魔力。