# Crash Course: entity component system



Michele Caini edited this page 15 days ago · [65 revisions](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system/_history)

2020/8/19

# Crash Course: entity-component system

# Table of Contents

- [Introduction](#introduction)
- [Design decisions](Design-decisions)
  - [A bitset-free entity-component system](#a-bitset-free-entity-component-system)
  - [Pay per use](#pay-per-use)
  - [All or nothing](#all-or-nothing)
  - [Stateless systems](#stateless-systems)
- [Vademecum](#vademecum)
- [Pools](#pools)
- The Registry, the Entity and the Component
  - Observe changes
    - [They call me Reactive System](#they-call-me-reactive-system)
  - [Sorting: is it possible?](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#sorting-is-it-possible)
  - Helpers
    - [Null entity](#null-entity)
    - [To entity](#to-entity)
    - [Dependencies](#dependencies)
    - [Invoke](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#invoke)
    - [Handle](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#handle)
    - [Context variables](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#context-variables)
  - Meet the runtime
    - [Cloning a registry](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#cloning-a-registry)
    - [Stamping an entity](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#stamping-an-entity)
  - Snapshot: complete vs continuous
    - [Snapshot loader](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#snapshot-loader)
    - [Continuous loader](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#continuous-loader)
    - [Archives](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#archives)
    - [One example to rule them all](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#one-example-to-rule-them-all)
- Views and Groups
  - [Views](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#views)
  - [Runtime views](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#runtime-views)
  - Groups
    - [Full-owning groups](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#full-owning-groups)
    - [Partial-owning groups](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#partial-owning-groups)
    - [Non-owning groups](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#non-owning-groups)
    - [Nested groups](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#nested-groups)
  - [Types: const, non-const and all in between](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#types-const-non-const-and-all-in-between)
  - [Give me everything](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#give-me-everything)
  - What is allowed and what is not
    - [More performance, more constraints](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#more-performance-more-constraints)
- [Empty type optimization](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#empty-type-optimization)
- Multithreading
  - [Iterators](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#iterators)
- [Beyond this document](https://github.com/skypjack/entt/wiki/Crash-Course:-entity-component-system#beyond-this-document)

# Introduction

`EnTT` is a header-only, tiny and easy to use entity-component system (and much more) written in modern C++.
The entity-component-system (also known as *ECS*) is an architectural pattern used mostly in game development.
EnTT是用现代C ++编写的仅头文件，微小且易于使用的实体组件系统。
实体组件系统（也称为* ECS *）是一种架构模式，主要用于游戏开发中。

# Design decisions

## A bitset-free entity-component system

`EnTT` offers a *bitset-free* entity-component system that doesn't require users to specify the set of components neither at compile-time nor at runtime.
EnTT提供了一个“无位集”实体组件系统，该系统不需要用户在编译时或运行时都指定组件集。
This is why users can instantiate the core class simply like:
这就是为什么用户可以像这样简单地实例化核心类的原因：

```
entt::registry registry;
```

In place of its more annoying and error-prone counterpart:
代替更烦人和易于出错的方法：

```
entt::registry<comp_0, comp_1, ..., comp_n> registry;
```

Furthermore, it isn't necessary to announce the existence of a component type. When the time comes, just use it and that's all.
此外，不必宣布组件类型的存在。 时间到了，就用它就够了。

## Pay per use

`EnTT` is entirely designed around the principle that users have to pay only for what they want.
EnTT完全基于用户只需为所需的商品付费的原则而设计。

When it comes to using an entity-component system, the tradeoff is usually between performance and memory usage. The faster it is, the more memory it uses. Even worse, some approaches tend to heavily affect other functionalities like the construction and destruction of components to favor iterations, even when it isn't strictly required. In fact, slightly worse performance along non-critical paths are the right price to pay to reduce memory usage and have overall better perfomance sometimes and I've always wondered why this kind of tools do not leave me the choice.
在使用实体组件系统时，通常要在性能和内存使用之间进行权衡。 速度越快，它使用的内存就越多。 更糟糕的是，即使不是严格要求，某些方法也往往会严重影响其他功能，例如构件的构造和破坏，以支持迭代。 实际上，非关键路径上的性能稍差是为减少内存使用并有时获得总体更好性能而付出的正确代价，我一直想知道为什么这种工具没有让我选择。
`EnTT` follows a completely different approach. It gets the best out from the basic data structures and gives users the possibility to pay more for higher performance where needed.
`EnTT`遵循完全不同的方法。 它可以从基本数据结构中获得最大的收益，并使用户有可能在需要时为更高的性能付费。

So far, this choice has proven to be a good one and I really hope it can be for many others besides me.
到目前为止，这一选择已被证明是一个不错的选择，我真的希望除我以外的许多人都能选择。

## All or nothing

`EnTT` is such that at every moment a pair `(T *, size)` is available to directly access all the instances of a given component type `T`.
`EnTT`使得每一时刻都有一对（T *，size）可用来直接访问给定组件类型T的所有实例。
This was a guideline and a design decision that influenced many choices, for better and for worse. I cannot say whether it will be useful or not to the reader, but it's worth to mention it since it's one of the corner stones of this library.
这是一个指导和一个设计决定，影响了很多选择，无论好坏，这都会影响到选择。 我不能说它是否对读者有用，但是值得一提的是它是该库的基础之一。

Many of the tools described below give the possibility to get this information and have been designed around this need.
下面介绍的许多工具都可以获取此信息，并且已围绕此需求进行了设计。
The rest is experimentation and the desire to invent something new, hoping to have succeeded.
剩下的就是实验，以及发明新事物的希望，希望能够成功。

## Stateless systems 无状态系统

`EnTT` is designed so that it can work with *stateless systems*. In other words, all systems can be free functions and there is no need to define them as classes (although nothing prevents users from doing so).
EnTT的设计使其可以与无状态系统一起使用。 换句话说，所有系统都可以是自由函数，无需将它们定义为类（尽管没有什么可以阻止用户这样做）。
This is possible because the main class with which the users will work provides all what is needed to act as the sole *source of truth* of an application.
这是可能的，因为用户将使用的主要类提供了充当应用程序的唯一“事实来源”所需的全部内容。

# Vademecum

The registry to store, the views and the groups to iterate. That's all.
要存储的注册表，要迭代的视图和组。 就这样。

An entity (the *E* of an *ECS*) is an opaque identifier that users should use as-is. Inspecting an identifier isn't recommended since its format can change in future and a registry has all the functionalities to query them out-of-the-box. The type `entt::entity` implements the concept of *entity identifier*.
实体（*ECS* *的* *E*）是用户应按原样使用的不透明标识符。 不建议检查标识符，因为它的格式将来可能会更改，并且注册表具有开箱即用地查询它们的所有功能。 类型“ entt :: entity”实现了“实体标识符”的概念。
Components (the *C* of an *ECS*) must be both move constructible and move assignable. They are list initialized by using the parameters provided to construct the component itself. No need to register components or their types neither with the registry nor with the entity-component system at all.
组件（*ECS* *的* *C* ）必须是可构造的和可分配的。 使用提供的用于构造组件本身的参数对它们进行列表初始化。 既不需要在注册表中也不需要在实体组件系统中注册组件或其类型。
Systems (the *S* of an *ECS*) can be plain functions, functors, lambdas and so on. It's not required to announce them in any case and have no requirements.
系统（*ECS*的* *S*）可以是普通函数，函子，lambda等。 无论如何都不需要宣布（声明）它们，也没有要求。

The following sections explain in short how to use the entity-component system, the core part of the whole library.
The project is composed of many other classes in addition to those describe below. For more details, please refer to the inline documentation.
以下各节简要说明了如何使用实体组件系统，它是整个库的核心部分。
除以下所述的项目外，该项目还包括许多其他的类。 有关更多详细信息，请参阅内联文档。

# Pools

In `EnTT`, pools of components are made available through a specialized version of a sparse set.
在“ EnTT”中，组件池i通过专用版本的稀疏集来实现的。

Each pool contains all the instances of a single component, as well as all the entities to which it's assigned. Sparse arrays are also *paged* to avoid wasting memory in some cases while packed arrays are not for obvious reasons.
每个池包含单个组件的所有实例以及为其分配到的所有实体。 稀疏数组也*分页*，以避免在某些情况下浪费内存，而打包数组并不是出于明显的原因。
Pools also make available at any time a pointer to the packed lists of entities and components they contain, in addition to the number of elements in use. For this reason, pools can rearrange their items in order to keep the internal arrays tightly packed and maximize performance.
除使用中的元素数量外，池还可以随时提供指向它们所包含的实体和组件的打包列表的指针。 因此，池可以重新排列其项目，以使内部阵列保持紧密包装并最大化性能。

At the moment, it's possible to specialize pools within certain limits, although a more flexible and user-friendly model is under development.
目前，尽管正在开发一种更加灵活和用户友好的模型，但仍可以在一定范围内专门化池。

# The Registry, the Entity and the Component

A registry can store and manage entities, as well as create views and groups to iterate the underlying data structures.
注册表可以存储和管理实体，还可以创建视图和组以迭代基础数据结构。
The class template `basic_registry` lets users decide what's the preferred type to represent an entity. Because `std::uint32_t` is large enough for almost all the cases, there exists also the enum class `entt::entity` that *wraps* it and the alias `entt::registry` for `entt::basic_registry<entt::entity>`.
类模板`basic_registry`使用户可以决定代表实体的首选类型。 因为`std::uint32_t`对于几乎所有情况都足够大，所以也存在枚举类的枚举类`entt::entity`和`entt::basic_registry`   `entt :: basic_registry<entt::entity>`。
waring:翻译不出来



Entities are represented by *entity identifiers*. An entity identifier carries information about the entity itself and its version.
User defined identifiers can be introduced by means of enum classes and custom types for which a specialization of `entt_traits` exists. For this purpose, `entt_traits` is also defined as a *sfinae-friendly* class template. In theory, integral types can also be used as entity identifiers, even though this may break in future and isn't recommended in general.
实体由*实体标识符*表示。 实体标识符携带有关实体本身及其版本的信息。
用户定义的标识符可以通过enent_traits的特殊化的枚举类和自定义类型来引入。 为此，“ entt_traits”也被定义为“对sfinae友好的”类模板。 从理论上讲，整数类型也可以用作实体标识符，即使将来可能会中断并且一般不建议这样做。

A registry is used both to construct and to destroy entities:

```
// constructs a naked entity with no components and returns its identifier
auto entity = registry.create();

// destroys an entity and all its components
registry.destroy(entity);
```

The `create` member function accepts also a hint and has an overload that gets two iterators and can be used to generate multiple entities at once efficiently. Similarly, the `destroy` member function works also with a range of entities:
create成员函数还接受一个提示，并具有一个获得两个迭代器的重载，可用于一次高效地生成多个实体。 类似地，`destroy`成员函数也适用于一系列实体：

```
// destroys all the entities in a range
auto view = registry.view<a_component, another_component>();
registry.destroy(view.begin(), view.end());
```

When an entity is destroyed, the registry can freely reuse it internally with a slightly different identifier. In particular, the version of an entity is increased after destruction (unless the overload that forces a version is used instead of the default one).
当实体被销毁时，注册表可以使用稍有不同的标识符在内部自由地重用它。 特别是，实体的版本在销毁后会增加（除非使用强制版本的重载而不是默认版本）。

Users can probe an identifier to know the information it carries:
用户可以探测标识符以了解其携带的信息：

```
// returns true if the entity is still valid, false otherwise
bool b = registry.valid(entity);

// gets the version contained in the entity identifier
auto version = registry.version(entity);

// gets the actual version for the given entity
auto curr = registry.current(entity);
```

Components can be assigned to or removed from entities at any time. As for the entities, the registry offers a set of functions to use to work with components.
可以随时将组件分配给实体或从实体中删除。 对于实体，注册表提供了一组用于处理组件的功能。

The `emplace` member function template creates, initializes and assigns to an entity the given component. It accepts a variable number of arguments to use to construct the component itself if present:
“ emplace”成员函数模板创建，初始化并将给定的组件分配给实体。 如果存在的话，它接受可变数量的参数来构造组件本身：

```
registry.emplace<position>(entity, 0., 0.);

// ...

auto &vel = registry.emplace<velocity>(entity);
vel.dx = 0.;
vel.dy = 0.;
```

Similarly, `insert` does it for multiple entities and accepts a range rather than a single entity in order to:
类似地，“插入”对多个实体执行此操作，并接受范围而不是单个实体，以便：

- Assign the same component to all entities at once when a type is specified as a template parameter or an instance is passed as an argument:
  在将类型指定为模板参数或将实例作为参数传递时，立即将同一组件分配给所有实体：

  ```
  // default initialized type assigned by copy to all entities
  registry.insert<position>(first, last);
  
  // user-defined instance assigned by copy to all entities
  registry.insert(from, to, position{0., 0.});
  ```

- Assign a range of components to the entities when a range is provided (the length of the range of components must be the same of that of entities):
  当提供范围时，为实体分配范围的组件（组件范围的长度必须与实体的长度相同）：

  ```
  // first and last specify the range of entities, instances points to the first element of the range of components
  registry.insert<position>(first, last, instances);
  ```

If an entity already has the given component, the `replace` and `patch` member function templates can be used to update it:
如果实体已经具有给定的组件，则可以使用`replace`和`patch`成员函数模板来更新它：

```
// replaces the component in-place
registry.patch<position>(entity, [](auto &pos) { pos.x = pos.y = 0.; });

// constructs a new instance from a list of arguments and replaces the component
registry.replace<position>(entity, 0., 0.);
```

When it's unknown whether an entity already owns an instance of a component, `emplace_or_replace` is the function to use instead:
当不清楚某个实体是否已经拥有某个组件的实例时，可以使用`emplace_or_replace`函数：

```
registry.emplace_or_replace<position>(entity, 0., 0.);
```

This is a slightly faster alternative for the following snippet:
对于以下代码段，这是一种稍快的替代方法：

```
if(registry.has<velocity>(entity)) {
    registry.replace<velocity>(entity, 0., 0.);
} else {
    registry.emplace<velocity>(entity, 0., 0.);
}
```

The `has` and `any` member functions may also be useful if in doubt about whether or not an entity has all the components in a set or any of them:
如果对实体是否具有集合中的所有组件或其中的任何一个组件有疑问，则`has`和`any`成员函数也可能有用：

```
// true if entity has all the given components
bool all = registry.has<position, velocity>(entity);

// true if entity has at least one of the given components
bool any = registry.any<position, velocity>(entity);
```

If the goal is to delete a single component from an entity that owns it, the `remove` member function template is the way to go:
如果目标是从拥有它的实体中删除单个组件，则可以使用`remove`成员函数模板：

```
registry.remove<position>(entity);
```

When in doubt whether the entity owns the component, use the `remove_if_exists` member function instead. It behaves similarly to `remove` but it discards the component if and only if it exists, otherwise it returns safely to the caller:
如果不确定实体是否拥有该组件，请改用`remove_if_exists`成员函数。 它的行为与`remove`类似，但是当且仅当该组件存在时，它才会丢弃该组件，否则它将安全返回给调用者：

```
registry.remove_if_exists<position>(entity);
```

The `clear` member function works similarly and can be used to either:
“ clear”成员函数的工作原理类似，可用于以下任一情况：

- Remove all instances of the given components from the entities that own them:
  从拥有它们的实体中删除给定组件的所有实例：

  ```
  registry.clear<position>();
  ```

- Or destroy all entities in a registry at once:
  或一次销毁注册表中的所有实体：

  ```
  registry.clear();
  ```

Finally, references to components can be retrieved simply as:
最后，可以简单地通过以下方式检索对组件的引用：

```
const auto &cregistry = registry;

// const and non-const reference
const auto &crenderable = cregistry.get<renderable>(entity);
auto &renderable = registry.get<renderable>(entity);

// const and non-const references
const auto [cpos, cvel] = cregistry.get<position, velocity>(entity);
auto [pos, vel] = registry.get<position, velocity>(entity);
```

The `get` member function template gives direct access to the component of an entity stored in the underlying data structures of the registry. There exists also an alternative member function named `try_get` that returns a pointer to the component owned by an entity if any, a null pointer otherwise.
`get`成员函数模板可直接访问存储在注册表基础数据结构中的实体的组件。 还有一个名为`try_get`的替代成员函数，该成员函数返回指向实体所拥有的组件的指针（如果有的话），否则返回空指针。

## Observe changes观察变化

Because of how the registry works internally, it stores a bunch of signal handlers for each pool in order to notify some of its data structures on the construction and destruction of components or when an instance of a component is explicitly replaced by the user.
由于注册表在内部是如何工作的，因此它为每个池存储一堆信号处理程序，以便在组件的构造和破坏或用户显式替换组件实例时通知其某些数据结构。

These signal handlers are also exposed and made available to users. These are the basic bricks to build fancy things like dependencies and reactive systems.
这些信号处理程序也公开给用户使用。 这些是构建诸如依赖和反应系统之类的奇特事物的基础。

To get a sink to be used to connect and disconnect listeners so as to be notified on the creation of a component, use the `on_construct` member function:
为了使接收器用于连接和断开侦听器，以便在创建组件时得到通知，请使用`on_construct`成员函数：

```
// connects a free function
registry.on_construct<position>().connect<&my_free_function>();

// connects a member function
registry.on_construct<position>().connect<&my_class::member>(instance);

// disconnects a free function
registry.on_construct<position>().disconnect<&my_free_function>();

// disconnects a member function
registry.on_construct<position>().disconnect<&my_class::member>(instance);

```

To be notified when components are destroyed, use the `on_destroy` member function instead. Finally, the `on_update` member function will return a sink to which to connect listeners to observe changes.
要在组件销毁时得到通知，请改用`on_destroy`成员函数。 最后，`on_update`成员函数将返回一个接收器，接收者可以连接到接收器以观察变化。

In the last case, given the way C++ works, it's also necessary to use specific member functions to allow the signal to be triggered. In particular, listeners attached to `on_update` will only be invoked following a call to `replace` or `patch`.
在最后一种情况下，考虑到C ++的工作方式，还必须使用特定的成员函数来允许信号被触发。 特别是，附加在on_update上的监听器将仅在调用`replace`或`patch`之后被调用。

The function type of a listener should be equivalent to the following:
侦听器的功能类型应等效于以下内容：

```
void(entt::registry &, entt::entity);

```

In all cases, listeners are provided with the registry that triggered the notification and the involved entity.
在所有情况下，都为侦听器提供了触发通知的注册表以及所涉及的实体。

Note also that:另请注意：

- Listeners for the construction signals are invoked **after** components have been assigned to entities.
  在将**组件分配给实体后，将调用构造信号的侦听器。
- Listeners designed to observe changes are invoked **after** components have been updated.
  在组件更新后**，将调用旨在观察更改的侦听器。
- Listeners for the destruction signals are invoked **before** components have been removed from entities.
  在从实体中删除组件之前，**会调用销毁信号的侦听器。

There are also some limitations on what a listener can and cannot do:
侦听者可以做什么和不能做什么也有一些限制：

- Connecting and disconnecting other functions from within the body of a listener should be avoided. It can lead to undefined behavior in some cases.
  应该避免在侦听器体内连接和断开其他功能。 在某些情况下，它可能导致不确定的行为。
- Removing the component from within the body of a listener that observes the construction or update of instances of a given type isn't allowed.
  不允许从用于观察给定类型的实例的构造或更新的侦听器主体中删除该组件。
- Assigning and removing components from within the body of a listener that observes the destruction of instances of a given type should be avoided. It can lead to undefined behavior in some cases. This type of listeners is intended to provide users with an easy way to perform cleanup and nothing more.
  应该避免在侦听器的主体内分配和删除观察到给定类型的实例的破坏的组件。 在某些情况下，它可能导致不确定的行为。 这种类型的侦听器旨在为用户提供一种执行清理的简便方法，仅此而已。

To a certain extent, these limitations don't apply. However, it's risky to try to force them and users should respect the limitations unless they know exactly what they are doing.
在一定程度上，这些限制不适用。 但是，尝试强迫他们冒险，除非用户确切知道自己在做什么，否则用户应遵守这些限制。

Events and therefore listeners must not be used as replacements for systems. They shouldn't contain much logic and interactions with a registry should be kept to a minimum. Moreover, the greater the number of listeners, the greater the performance hit when components are created or destroyed.
事件和侦听器不能用作系统的替代品。 它们不应包含太多逻辑，应尽量减少与注册表的交互。 此外，侦听器的数量越多，创建或销毁组件时的性能损失就越大。

Please, refer to the documentation of the signal class to know all the features it offers.请参阅信号类的文档以了解其提供的所有功能。
There are many useful but less known functionalities that aren't described here, such as the connection objects or the possibility to attach listeners with a list of parameters that is shorter than that of the signal itself.
这里有许多有用的但鲜为人知的功能，此处未描述，例如连接对象或为侦听器附加一个比信号本身短的参数列表的可能性。

### They call me Reactive System 反应系统

Signals are the basic tools to construct reactive systems, even if they aren't enough on their own. `EnTT` tries to take another step in that direction with the `observer` class template.
信号是构建反应系统的基本工具，即使仅靠信号还不够。 EnTT试图通过observer类模板朝这个方向迈出另一步。

In order to explain what reactive systems are, this is a slightly revised quote from the documentation of the library that first introduced this tool, [Entitas](https://github.com/sschmid/Entitas-CSharp):
为了解释什么是反应性系统，这是对首次引入此工具[Entitas](https://github.com/sschmid/Entitas-CSharp)的库文档的稍作修改的引用：

> Imagine you have 100 fighting units on the battlefield but only 10 of them changed their positions. Instead of using a normal system and updating all 100 entities depending on the position, you can use a reactive system which will only update the 10 changed units. So efficient.
> 想象一下，您在战场上有100个战斗部队，但其中只有10个改变了阵地。 除了使用常规系统并根据位置更新所有100个实体外，您还可以使用反应式系统，该系统仅更新10个更改的单位。 如此高效。

In `EnTT`, this means to iterating over a reduced set of entities and components with respect to what would otherwise be returned from a view or a group.
在“ EnTT”中，这意味着相对于从视图或组返回的内容，迭代减少的一组实体和组件。
On these words, however, the similarities with the proposal of `Entitas` also end. The rules of the language and the design of the library obviously impose and allow different things.
然而，在这些词上，与“ Entitas”提案的相似性也结束了。 语言的规则和库的设计显然强加并允许不同的事物。

An `observer` is initialized with an instance of a registry and a set of rules that describes what are the entities to intercept. As an example:
“观察者”由注册表实例和描述要拦截的实体的一组规则初始化。 举个例子：

```
entt::observer observer{registry, entt::collector.update<sprite>()};

```

The class is default constructible and can be reconfigured at any time by means of the `connect` member function. Moreover, instances can be disconnected from the underlying registries through the `disconnect` member function.
该类是默认可构造的，并且可以随时通过`connect`成员函数进行重新配置。 此外，实例可以通过`disconnect`成员函数与基础注册表断开连接。
The `observer` offers also what is needed to query the internal state and to know if it's empty or how many entities it contains. Moreover, it can return a raw pointer to the list of entities it contains.
“观察者”还提供查询内部状态并知道其是否为空或包含多少个实体所需的内容。 而且，它可以返回指向其包含的实体列表的原始指针。

However, the most important features of this class are that:
但是，此类的最重要特征是：

- It's iterable and therefore users can easily walk through the list of entities by means of a range-for loop or the `each` member function.
  它是可迭代的，因此用户可以通过range-for循环或`each`成员函数轻松浏览实体列表。
- It's clearable and therefore users can consume the entities and literally reset the observer after each iteration.
  它是可清除的，因此用户可以使用实体并在每次迭代后从字面上重置观察者。

These aspects make the observer an incredibly powerful tool to know at any time what are the entities that matched the given rules since the last time one asked:
这些方面使观察者成为了一种非常强大的工具，可以随时知道自上次询问以来与给定规则匹配的实体是什么：

```
for(const auto entity: observer) {
    // ...
}

observer.clear();

```

The snippet above is equivalent to the following:
上面的代码段等效于以下内容：

```
observer.each([](const auto entity) {
    // ...
});
```

At least as long as the `observer` isn't const. This means that the non-const overload of `each` does also reset the underlying data structure before to return to the caller, while the const overload does not for obvious reasons.
至少只要观察者不是const。 这意味着`each`的非const重载在返回到调用者之前也确实重置了基础数据结构，而const重载并不是出于明显的原因。

The `collector` is an utility aimed to generate a list of `matcher`s (the actual rules) to use with an `observer` instead.
收集器是一个实用程序，旨在生成匹配器列表（实际规则），供观察者使用。There are two types of `matcher`s:
这是’匹配器‘的有两种类型：

- Observing matcher: an observer will return at least all the living entities for which one or more of the given components have been updated and not yet destroyed.
  观察匹配者：观察者将至少返回所有已更新其一个或多个给定组件且尚未销毁的生物实体。

  ```
  entt::collector.update<sprite>();
  ```

  *Updated* in this case means that all listeners attached to `on_update` are invoked. In order for this to happen, specific functions such as `patch` must be used. Refer to the specific documentation for more details.
  在这种情况下，* Updated *表示将调用所有附加到on_update上的侦听器。 为了做到这一点，必须使用诸如“ patch”之类的特定功能。 有关更多详细信息，请参阅特定的文档。

- Grouping matcher: an observer will return at least all the living entities that would have entered the given group if it existed and that would have not yet left it.
  分组匹配器：观察者将至少返回将进入给定组（如果存在且尚未离开组）的所有活动实体。

  ```
  entt::collector.group<position, velocity>(entt::exclude<destroyed>);
  ```

  A grouping matcher supports also exclusion lists as well as single components.
  分组匹配器还支持排除列表以及单个组件。

Roughly speaking, an observing matcher intercepts the entities for which the given components are updated while a grouping matcher tracks the entities that have assigned the given components since the last time one asked.
粗略地说，观察匹配器拦截给定组件已更新的实体，而分组匹配器跟踪自上次询问以来已分配给定组件的实体。
If an entity already has all the components except one and the missing type is assigned to it, the entity is intercepted by a grouping matcher.
如果一个实体已经具有除一个以外的所有组件，并且为它分配了缺少的类型，则该实体将被分组匹配器拦截。

In addition, a matcher can be filtered with a `where` clause:
另外，可以使用`where`子句过滤匹配器：

```
entt::collector.update<sprite>().where<position>(entt::exclude<velocity>);

```

This clause introduces a way to intercept entities if and only if they are already part of a hypothetical group. If they are not, they aren't returned by the observer, no matter if they matched the given rule.
本节介绍了一种方法，当且仅当实体已经是假设组的一部分时，才可以对其进行拦截。 如果不是，则观察者不会返回它们，无论它们是否与给定规则匹配。
In the example above, whenever the component `sprite` of an entity is updated, the observer probes the entity itself to verify that it has at least `position` and has not `velocity` before to store it aside. If one of the two conditions of the filter isn't respected, the entity is discared, no matter what.
在上面的示例中，每当更新实体的组件“ sprite”时，观察者都会探查该实体本身以验证其至少具有“位置”并且没有“速度”，然后再将其存储在旁边。 如果不遵守过滤器的两个条件之一，则无论如何都将屏蔽实体。
A `where` clause accepts a theoretically unlimited number of types as well as multiple elements in the exclusion list. Moreover, every matcher can have its own clause and multiple clauses for the same matcher are combined in a single one.
一个where子句从理论上讲可以接受无限数量的类型以及排除列表中的多个元素。 而且，每个匹配器都可以有自己的子句，并且同一匹配器的多个子句可以组合成一个子句。

## Sorting: is it possible?

Sorting entities and components is possible with `EnTT`. In particular, it's feasible with an in-place algorithm that doesn't require memory allocations nor anything else and is therefore particularly convenient.
使用EnTT可以对实体和组件进行分类。 特别是，就地算法不需要内存分配也不需要任何其他操作，因此是特别可行的。
With this in mind, there are two functions that respond to slightly different needs:
考虑到这一点，有两个功能可以满足稍有不同的需求：

- Components can be sorted either directly:
  组件可以直接排序：

  ```
  registry.sort<renderable>([](const auto &lhs, const auto &rhs) {
      return lhs.z < rhs.z;
  });c
  ```

  Or by accessing their entities:
  或通过访问其实体：

  ```
  registry.sort<renderable>([](const entt::entity lhs, const entt::entity rhs) {
      return entt::registry::entity(lhs) < entt::registry::entity(rhs);
  });
  ```

  There exists also the possibility to use a custom sort function object for when the usage pattern is known. As an example, in case of an almost sorted pool, quick sort could be much slower than insertion sort.
  当已知使用模式时，也可能使用自定义排序功能对象。 例如，对于一个几乎已排序的池，快速排序可能比插入排序慢得多。

- Components can be sorted according to the order imposed by another component:
  可以根据其他组件施加的顺序对组件进行排序：

  ```
  registry.sort<movement, physics>();
  ```

  In this case, instances of `movement` are arranged in memory so that cache misses are minimized when the two components are iterated together.
  在这种情况下，“运动”的实例被安排在内存中，这样，当两个组件一起迭代时，高速缓存未命中率将降至最低。

As a side note, the use of groups limits the possibility of sorting pools of components. Refer to the specific documentation for more details.
附带说明，组的使用限制了对组件池进行排序的可能性。 有关更多详细信息，请参阅特定的文档。

## Helpers

The so called *helpers* are small classes and functions mainly designed to offer built-in support for the most basic functionalities.
所谓的* helpers *是小类和函数，主要用于为最基本的功能提供内置支持。
The list of helpers will grow longer as time passes and new ideas come out.
随着时间的流逝和新想法的出现，帮助者的名单将越来越长。

### Null entity

In `EnTT`, the `entt::null` variable models the concept of *null entity*.
The library guarantees that the following expression always returns false:
在`EnTT`中，`entt :: null`变量为* null实体*的概念建模。
该库保证以下表达式始终返回false：

```
registry.valid(entt::null);
```

A registry rejects the null entity in all cases because it isn't considered valid. It also means that the null entity cannot own components.
The type of the null entity is internal and should not be used for any purpose other than defining the null entity itself. However, there exist implicit conversions from the null entity to identifiers of any allowed type:
在所有情况下，注册表都会拒绝该空实体，因为它被认为无效。 这也意味着空实体不能拥有组件。
空实体的类型是内部的，除定义空实体本身外，不得用于任何目的。 但是，存在从空实体到任何允许类型的标识符的隐式转换：

```
entt::entity null = entt::null;
```

Similarly, the null entity can be compared to any other identifier:
类似地，可以将空实体与任何其他标识符进行比较：

```
const auto entity = registry.create();
const bool null = (entity == entt::null);
```

Be aware that `entt::null` and entity 0 aren't the same thing. Likewise, a zero initialized entity isn't the same as `entt::null`. Therefore, although `entt::entity{}` is in some sense an alias for entity 0, none of them can be used to create a null entity.
注意，`entt::null`和实体0不是同一回事。 同样，初始化为零的实体与`entt::null`不同。 因此，尽管从某种意义上说， `entt::entity {}`是实体0的别名，但是它们都不可用于创建空实体。

### To entity

Sometimes it's useful to get the entity from a component instance.
This is what the `entt::to_entity` helper does. It accepts a registry and an instance of a component and returns the entity associated with the latter:
有时从组件实例获取实体很有用。这就是`entt :: to_entity`助手的作用。 它接受注册表和组件实例，并返回与后者关联的实体：

```
const auto entity = entt::to_entity(registry, position);
```

This utility doesn't perform any check on the validity of the component. Therefore, trying to take the entity of an invalid element or of an instance that isn't associated with the given registry can result in undefined behavior.
该实用程序不对组件的有效性进行任何检查。 因此，尝试采用无效元素的实体或与给定注册表不相关的实例的实体可能导致未定义的行为。

### Dependencies

The `registry` class is designed to be able to create short circuits between its functions. This simplifies the definition of *dependencies* between different operations.
“ registry”类旨在能够在其功能之间造成短路。 这简化了不同操作之间的“依赖关系”的定义。
For example, the following adds (or replaces) the component `a_type` whenever `my_type` is assigned to an entity:
例如，每当将“ my_type”分配给实体时，以下代码就会添加（或替换）组件“ a_type”：

```
registry.on_construct<my_type>().connect<&entt::registry::emplace_or_replace<a_type>>();

```

Similarly, the code shown below removes `a_type` from an entity whenever `my_type` is assigned to it:
类似地，只要向实体分配了`my_type`，下面显示的代码就会从实体中删除“`a_type`：

```
registry.on_construct<my_type>().connect<&entt::registry::remove<a_type>>();
```

A dependency can also be easily broken as follows:
依存关系也可以很容易地被破坏，如下所示：

```
registry.on_construct<my_type>().disconnect<&entt::registry::emplace_or_replace<a_type>>();

```

There are many other types of dependencies. In general, most of the functions that accept an entity as the first argument are good candidates for this purpose.
还有许多其他类型的依赖项。 通常，大多数将实体作为第一个参数的函数都是用于此目的的良好候选者。

### Invoke

Sometimes it's useful to be able to directly invoke a member function of a component as a callback. It's already possible in practice but requires users to *extend* their classes and this may not always be possible.
有时能够直接调用组件的成员函数作为回调很有用。 在实践中已经可以实现，但是需要用户*扩展*他们的类，而这并非总是可能的。
The `invoke` helper allows to *propagate* the signal in these cases:
在以下情况下，`invoke`帮助程序可以“传播”信号：

```
registry.on_construct<clazz>().connect<entt::invoke<&clazz::func>>();

```

All it does is pick up the *right* component for the received entity and invoke the requested method, passing on the arguments if necessary.
它所做的就是为接收到的实体获取* right *组件并调用请求的方法，并在必要时传递参数。

### Handle

A handle is a thin wrapper around an entity and a registry. It provides the same functions that the registry offers for working with components, such as `emplace`, `get`, `patch`, `remove` and so on. The difference being that the entity is implicitly passed to the registry.
句柄是围绕实体和注册表的薄包装。 它提供了注册表提供的与组件一起使用的功能，例如emplace，get，patch，remove等。 区别在于实体是隐式传递给注册表的。

A handle is also non-owning, meaning that it can be freely copied and moved around without affecting its entity (in fact, handles happen to be trivially copyable). An implication of this is that mutability becomes part of the type.
句柄也是非所有者的，这意味着它可以自由复制和移动而不会影响其实体（实际上，句柄恰好是可复制的）。 这意味着可变性成为该类型的一部分。

There are two aliases that use `entt::entity` as their default entity: `entt::handle` and `entt::const_handle`. Users can also easily create their own aliases for custom identifiers as:
有两个使用“ entt :: entity”作为默认实体的别名：“ entt :: handle”和“ entt :: const_handle”。 用户还可以轻松地为自定义标识符创建自己的别名，如下所示：

```
using my_handle = entt::basic_handle<my_identifier>;
using my_const_handle = entt::basic_handle<const my_identifier>;

```

Handles are also implicitly convertible to const handles out of the box but not the other way around.
句柄也可以直接转换为const句柄，但不能反过来。

A handle stores a non-const pointer to a registry and therefore it can do all the things that can be done with a non-const registry. On the other hand, a const handles store const pointers to registries and offer a restricted set of functionalities.
句柄存储指向注册表的非常量指针，因此它可以完成非常量注册表可以完成的所有操作。 另一方面，const处理存储指向注册表的const指针，并提供一组受限制的功能。

This class is intended to simplify function signatures. In case of functions that take a registry and an entity and do most of their work on that entity, users might want to consider using handles, either const or non-const.
此类旨在简化功能签名。 对于具有注册表和实体并在该实体上完成其大部分工作的功能，用户可能要考虑使用const或非const句柄。

### Context variables上下文变量

It is often convenient to assign context variables to a registry, so as to make it the only *source of truth* of an application.
将上下文变量分配给注册表通常很方便，以便使其成为应用程序的唯一“真相”来源。
This is possible by means of a member function named `set` to use to create a context variable from a given type. Either `ctx` or `try_ctx` can be used to retrieve the newly created instance, while `unset` is meant to clear the variable if needed.
这可以通过名为`set`的成员函数来根据给定类型创建上下文变量来实现。 `ctx`或`try_ctx`均可用于检索新创建的实例，而`unset`则用于在需要时清除变量。

Example of use:

```
// creates a new context variable initialized with the given values
registry.set<my_type>(42, 'c');

// gets the context variable
const auto &var = registry.ctx<my_type>();

// if in doubts, probe the registry to avoid assertions in case of errors
//如有疑问，请探查注册表以避免在出现错误的情况下声明
if(auto *ptr = registry.try_ctx<my_type>(); ptr) {
    // uses the context variable associated with the registry, if any
}

// unsets the context variable
registry.unset<my_type>();

```

The type of a context variable must be such that it's default constructible and can be moved. The `set` member function either creates a new instance of the context variable or overwrites an already existing one if any. The `try_ctx` member function returns a pointer to the context variable if it exists, otherwise it returns a null pointer.
上下文变量的类型必须是默认可构造的并且可以移动。 set成员函数要么创建上下文变量的新实例，要么覆盖已经存在的实例（如果有）。 成员函数`try_ctx`返回指向上下文变量的指针（如果存在），否则返回空指针。

## Meet the runtime满足运行时

Type identifiers are stable in `EnTT` during executions and most of the times also across different executions and across boundaries. This makes them suitable to mix runtime and compile-time features.
在执行期间，类型标识符在EnTT中是稳定的，并且在大多数情况下，跨不同的执行和边界也是如此。 这使它们适合于混合运行时和编译时功能。
The registry offers a function to *visit* it and get the types of components it manages:
注册表提供了“访问”并获取其管理的组件类型的功能：

```
registry.visit([](const auto component) {
    // ...
});
```

Moreover, there exists an overload to *visit* a specific entity:
而且，存在一个重载来*visit* 访问特定实体存在：

```
registry.visit(entity, [](const auto component) {
    // ...
});
```

This helps to create a bridge between the registry, that is heavily based on the C++ type system, and any other context where the compile-time isn't an option. For example: plugin systems, meta system, serialization, and so on.
这有助于在很大程度上基于C ++类型系统的注册表和其他不能选择编译时的上下文之间建立桥梁。 例如：插件系统，元系统，序列化等。

### Cloning a registry

Cloning a registry isn't a suggested practice since it could trigger many copies and cut down the performance. Moreover, because of how the `registry` class is designed, supporting this as a built-in feature would increase the compilation times also for the users that aren't interested in cloning. Even worse, it would make difficult to define different *cloning policies* for different types when required.
建议不要克隆注册表，因为它可能会触发许多副本并降低性能。 此外，由于“ registry”类的设计方式，将其作为内置功能支持也会增加对克隆不感兴趣的用户的编译时间。 更糟的是，在需要时很难为不同的类型定义不同的“克隆策略”。
This is why function definitions for cloning have been moved to the user space. The `visit` member function of the `registry` class can help filling the gap, along with the `insert` functionality.
这就是为什么用于克隆的函数定义已移至用户空间的原因。 `registry` 类的`visit` 成员函数可以与`insert` 功能一起帮助填补空白。

A general purpose cloning function could be defined as:
通用克隆功能可以定义为：

```
template<typename Type>
void clone(const entt::registry &from, entt::registry &to) {
    const auto *data = from.data<Type>();
    const auto size = from.size<Type>();

    if constexpr(ENTT_IS_EMPTY(Type)) {
        to.insert<Type>(data, data + size);
    } else {
        const auto *raw = from.raw<Type>();
        to.insert<Type>(data, data + size, raw, raw + size);
    }
}

```

This is probably the fastest method to inject entities and components in a registry that isn't necessarily empty. All new elements are *appended* to the existing ones, if any.
这可能是在不一定为空的注册表中注入实体和组件的最快方法。 如果有的话，所有新元素都“附加”到现有元素上。
This function is also eligible for type erasure in order to create a mapping between type identifiers and opaque methods for cloning:
此函数还可以进行类型擦除，以便在类型标识符和不透明的克隆方法之间创建映射：

```
using clone_fn_type = void(const entt::registry &, entt::registry &);
std::unordered_map<entt::id_type, clone_fn_type *> clone_functions;

// ...

clone_functions[entt::type_info<position>::id()] = &clone<position>;
clone_functions[entt::type_info<velocity>::id()] = &clone<velocity>;
```

Stamping a registry becomes straightforward with such a mapping then:
使用这样的映射对注册表进行标记变得很简单，然后：

```
entt::registry from;
entt::registry to;

// ...

from.visit([this, &to](const auto type_id) {
    clone_functions[type_id](from, to);
});
```

Custom cloning functions are also pretty easy to define. Moreover, also cloning registries specialized with different identifiers is possible this way.
自定义克隆功能也很容易定义。 此外，也可以通过这种方式克隆专门使用不同标识符的注册表。
As a side note, cloning functions could be also attached to a reflection system where meta types are resolved using the runtime type identifiers.
作为附带说明，也可以将克隆功能附加到反射系统，在该反射系统中，使用运行时类型标识符解析元类型。

### Stamping an entity

Using multiple registries at the same time is quite common. Examples are the separation of the UI from the simulation or the loading of different scenes in the background, possibly on a separate thread, without having to keep track of which entity belongs to which scene.
同时使用多个注册表非常普遍。 示例包括从仿真中分离UI或在后台将不同场景加载到后台（可能在单独的线程上），而不必跟踪哪个实体属于哪个场景。
In fact, with `EnTT` this is even a recommended practice, as the registry is nothing more than an opaque container you can swap at any time.
实际上，使用EnTT甚至是推荐的做法，因为注册表不过是一个可以随时交换的不透明容器。

Once there are multiple registries available, one or more methods are needed to transfer information from one container to another though.
一旦有多个注册表，就需要一种或多种方法将信息从一个容器传输到另一个容器。
This is where the `visit` member function of the `registry` class enters the game.
这是`registry`类的`visit`成员函数进入游戏的地方。

Since stamping a component could require different methods for different types and not all users want to benefit from this feature, function definitions have been moved from the registry to the user space.
由于标记组件可能需要针对不同类型的不同方法，并且并非所有用户都希望从此功能中受益，因此功能定义已从注册表移至用户空间。
This helped to reduce compilation times and to allow for maximum flexibility, even though it requires users to set up their own stamping functions.
即使需要用户设置自己的冲压功能，这也有助于减少编译时间并提供最大的灵活性。

The best bet here is probably to define a reflection system or a mapping between the type identifiers and their opaque functions for stamping. As an example:
这里最好的选择可能是定义一个反射系统或类型标识符与其用于冲压的不透明函数之间的映射。 举个例子：

```
template<typename Type>
void stamp(const entt::registry &from, const entt::entity src, entt::registry &to, const entt::entity dst) {
    to.emplace_or_replace<Type>(dst, from.get<Type>(src));
}
```

If the definition above is treated as a general purpose function for stamping, one can easily construct a map like the following one as a data member of a dedicate system:
如果将上面的定义视为用于标记的通用函数，则可以轻松地将如下图作为专用系统的数据成员来构造图：

```
using stamp_fn_type = void(const entt::registry&, const entt::entity, entt::registry&, const entt::entity);
std::unordered_map<entt::id_type, stamp_fn_type*> stamp_functions;

// ...

stamp_functions[entt::type_info<position>::id()] = &stamp<position>;
stamp_functions[entt::type_info<velocity>::id()] = &stamp<velocity>;
```

Then *stamp* entities across different registries as:
然后跨不同注册表的*stamp* 实体为：

```
entt::registry from;
entt::registry to;

// ...

from.visit(src, [this, &to, dst](const auto type_id) {
    stamp_functions[type_id](from, src, to, dst);
});
```

This way it's also pretty easy to define custom stamping functions for *special* types if needed. Moreover, stamping entities across registries specialized with different identifiers is possibile in practice.
这样，如果需要，还可以为*特殊*类型定义自定义标记功能。 而且，在实践中，跨注册管理机构的专门为不同标识符标识的实体是可能的。

## Snapshot: complete vs continuous 快照：完整与连续

The `registry` class offers basic support to serialization.
It doesn't convert components to bytes directly, there wasn't the need of another tool for serialization out there. Instead, it accepts an opaque object with a suitable interface (namely an *archive*) to serialize its internal data structures and restore them later. The way types and instances are converted to a bunch of bytes is completely in charge to the archive and thus to final users.
 `registry`类为序列化提供基本支持。
它不会将组件直接转换为字节，因此不需要其他工具来进行序列化。 相反，它接受带有适当接口（即*archive*）的不透明对象以序列化其内部数据结构并在以后还原它们。 将类型和实例转换为一堆字节的方式完全由档案馆负责，因此由最终用户负责。

The goal of the serialization part is to allow users to make both a dump of the entire registry or a narrower snapshot, that is to select only the components in which they are interested.
序列化部分的目标是允许用户转储整个注册表或缩小快照范围，即仅选择他们感兴趣的组件。
Intuitively, the use cases are different. As an example, the first approach is suitable for local save/restore functionalities while the latter is suitable for creating client-server applications and for transferring somehow parts of the representation side to side.
直观上，用例是不同的。 例如，第一种方法适用于本地保存/恢复功能，而后者适用于创建客户端-服务器应用程序以及以某种方式左右传递表示的部分。
To take a snapshot of a registry, use the `snapshot` class:
要拍摄注册表快照，请使用`snapshot`类：

```
output_archive output;

entt::snapshot{registry}
    .entities(output)
    .component<a_component, another_component>(output);
```

It isn't necessary to invoke all functions each and every time. What functions to use in which case mostly depends on the goal and there is not a golden rule for that.
不必每次都调用所有函数。 在这种情况下，要使用什么功能主要取决于目标，因此没有一个黄金法则。

The `entities` member function makes the snapshot serialize all entities (both those still alive and those destroyed) along with their versions.
“实体”成员函数使快照可以序列化所有实体（仍在活动中的实体和被破坏的实体）及其版本。
On the other hand, the `component` member function is a function template the aim of which is to store aside components. The presence of a template parameter list is a consequence of a couple of design choices from the past and in the present:
另一方面，`component`成员函数是一个功能模板，其目的是存储备用组件。 模板参数列表的存在是过去和现在的几个设计选择的结果：

- First of all, there is no reason to force a user to serialize all the components at once and most of the times it isn't desiderable. As an example, in case the stuff for the HUD in a game is put into the registry for some reasons, its components can be freely discarded during a serialization step because probably the software already knows how to reconstruct them correctly.
  首先，没有理由强迫用户一次序列化所有组件，并且在大多数情况下是不希望的。 例如，如果出于某种原因将游戏中HUD的内容放入注册表中，则可以在序列化步骤中自由丢弃其HUD组件，因为该软件可能已经知道如何正确重构它们。
- Furthermore, the registry makes heavy use of *type-erasure* techniques internally and doesn't know at any time what component types it contains. Therefore being explicit at the call site is mandatory.
  此外，注册表在内部大量使用* type-erasure *技术，并且不知道它包含什么组件类型。 因此，在呼叫站点必须明确。

There exists also another version of the `component` member function that accepts a range of entities to serialize. This version is a bit slower than the other one, mainly because it iterates the range of entities more than once for internal purposes. However, it can be used to filter out those entities that shouldn't be serialized for some reasons.
还有一个`component`成员函数的版本，它接受一系列要序列化的实体。 这个版本比另一个版本慢一点，主要是因为出于内部目的，它多次迭代实体范围。 但是，由于某些原因，它可以用来过滤那些不应该序列化的实体。

As an example:

```
const auto view = registry.view<serialize>();
output_archive output;

entt::snapshot{registry}
.component<a_component,another_component>
(output, view.cbegin(), view.cend());
```

Note that `component` stores items along with entities. It means that it works properly without a call to the `entities` member function.
请注意，`component`会与实体一起存储项目。 这意味着它可以正常工作而无需调用`entities`成员函数。

Once a snapshot is created, there exist mainly two *ways* to load it: as a whole and in a kind of *continuous mode*.
The following sections describe both loaders and archives in details.
创建快照后，主要有两种加载方式：*整体*和一种*连续模式*。
以下各节详细介绍了装载程序和归档文件。

### Snapshot loader

A snapshot loader requires that the destination registry be empty and loads all the data at once while keeping intact the identifiers that the entities originally had.
快照加载器要求目标注册表为空，并一次加载所有数据，同时保持实体最初具有的标识符不变。

To use it, just pass to the constructor a valid registry:
要使用它，只需将一个有效的注册表传递给构造函数：

```
input_archive input;

entt::snapshot_loader{registry}
    .entities(input)
    .component<a_component, another_component>(input)
    .orphans();
```

It isn't necessary to invoke all functions each and every time. What functions to use in which case mostly depends on the goal and there is not a golden rule for that. For obvious reasons, what is important is that the data are restored in exactly the same order in which they were serialized.
不必每次都调用所有函数。 在这种情况下，要使用什么功能主要取决于目标，因此没有一个黄金法则。 出于显而易见的原因，重要的是要以与序列化完全相同的顺序还原数据。

The `entities` member function restores the sets of entities and the versions that they originally had at the source.
`entities` 成员函数可恢复实体集以及它们最初在源中具有的版本。

The `component` member function restores all and only the components specified and assigns them to the right entities. Note that the template parameter list must be exactly the same used during the serialization.
component成员函数仅恢复指定的所有组件，并将它们分配给正确的实体。 请注意，模板参数列表必须与序列化过程中使用的完全相同。

The `orphans` member function literally destroys those entities that have no components attached. It's usually useless if the snapshot is a full dump of the source. However, in case all the entities are serialized but only few components are saved, it could happen that some of the entities have no components once restored. The best the users can do to deal with them is to destroy those entities and thus update their versions.
`orphans`成员函数实际上会破坏那些没有附加组件的实体。 如果快照是源的完整转储，通常没有用。 但是，如果所有实体都已序列化但仅保存了很少（一部分）的组件，则可能会发生某些实体一旦恢复就没有组件的情况。 用户最好的应对方法是销毁这些实体，从而更新其版本。

### Continuous loader 持续化加载器

A continuous loader is designed to load data from a source registry to a (possibly) non-empty destination. The loader can accommodate in a registry more than one snapshot in a sort of *continuous loading* that updates the destination one step at a time.
连续加载程序旨在将数据从源注册表加载到（可能是）非空目标。 加载程序可以以一种“连续加载”的形式在注册表中容纳多个快照，这些快照可以一次更新目标位置。
Identifiers that entities originally had are not transferred to the target. Instead, the loader maps remote identifiers to local ones while restoring a snapshot. Because of that, this kind of loader offers a way to update automatically identifiers that are part of components (as an example, as data members or gathered in a container).
实体最初拥有的标识符不会转移到目标。 相反，加载器在还原快照时将远程标识符映射到本地标识符。 因此，这种加载器提供了一种自动更新标识符的方法，这些标识符是组件的一部分（例如，作为数据成员或收集在容器中）。
Another difference with the snapshot loader is that the continuous loader has an internal state that must persist over time. Therefore, there is no reason to limit its lifetime to that of a temporary object.
快照加载器的另一个区别是连续加载器具有必须随着时间推移而持续存在的内部状态。 因此，没有理由将其寿命限制为临时对象的寿命。

Example of use:

```
entt::continuous_loader loader{registry};
input_archive input;

loader.entities(input)
    .component<a_component, another_component, dirty_component>(input, &dirty_component::parent, &dirty_component::child)
    .orphans()
    .shrink();

```

It isn't necessary to invoke all functions each and every time. What functions to use in which case mostly depends on the goal and there is not a golden rule for that. For obvious reasons, what is important is that the data are restored in exactly the same order in which they were serialized.
不必每次都调用所有函数。 在这种情况下，要使用什么功能主要取决于目标，因此没有一个黄金法则。 出于显而易见的原因，重要的是要以与序列化完全相同的顺序还原数据。

The `entities` member function restores groups of entities and maps each entity to a local counterpart when required. In other terms, for each remote entity identifier not yet registered by the loader, it creates a local identifier so that it can keep the local entity in sync with the remote one.
“实体”成员函数可还原实体组，并在需要时将每个实体映射到本地副本。 换句话说，对于尚未由加载程序注册的每个远程实体标识符，它创建一个本地标识符，以便它可以使本地实体与远程实体保持同步。

The `component` member function restores all and only the components specified and assigns them to the right entities.
In case the component contains entities itself (either as data members of type `entt::entity` or as containers of entities), the loader can update them automatically. To do that, it's enough to specify the data members to update as shown in the example.
component成员函数仅恢复指定的所有组件，并将它们分配给正确的实体。
如果组件本身包含实体（作为`entt :: entity`类型的数据成员或作为实体的容器），则加载程序可以自动更新它们。 为此，只需指定要更新的数据成员即可，如示例中所示。

The `orphans` member function literally destroys those entities that have no components after a restore. It has exactly the same purpose described in the previous section and works the same way.
“ orphans”成员函数从字面上看会破坏还原后没有任何组件的那些实体。 它具有上一部分中所述的完全相同的目的，并且以相同的方式工作。

Finally, `shrink` helps to purge local entities that no longer have a remote conterpart. Users should invoke this member function after restoring each snapshot, unless they know exactly what they are doing.
最后，“缩小”有助于清除不再具有远程对等关系的本地实体。 用户应在还原每个快照后调用此成员函数，除非他们确切地知道自己在做什么。

### Archives

Archives must publicly expose a predefined set of member functions. The API is straightforward and consists only of a group of function call operators that are invoked by the snapshot class and the loaders.
存档必须公开公开一组预定义的成员函数。 该API非常简单，仅由快照类和加载程序调用的一组函数调用运算符组成。

In particular:特别是：

- An output archive, the one used when creating a snapshot, must expose a function call operator with the following signature to store entities:
  输出存档（创建快照时使用的存档）必须公开具有以下签名的函数调用运算符以存储实体：

  ```
  void operator()(entt::entity);
  
  ```

  Where `entt::entity` is the type of the entities used by the registry.
  Note that all member functions of the snapshot class make also an initial call to store aside the *size* of the set they are going to store. In this case, the expected function type for the function call operator is:
  其中当`entt::entity`是注册表使用的实体的类型。请注意，快照类的所有成员函数还进行了一次初始调用，以将它们要存储的集合的*size*分开存储。 在这种情况下，函数调用运算符的预期函数类型为：

  ```
  void operator()(std::underlying_type_t<entt::entity>);
  ```

  In addition, an archive must accept a pair of entity and component for each type to be serialized. Therefore, given a type `T`, the archive must contain a function call operator with the following signature:
  此外，对于要序列化的每种类型，档案必须接受一对实体和组件。 因此，在给定类型为T的情况下，归档文件必须包含具有以下签名的函数调用运算符：

  ```
  void operator()(entt::entity, const T &);
  ```

  The output archive can freely decide how to serialize the data. The register is not affected at all by the decision.
  输出档案可以自由决定如何序列化数据。 该寄存器完全不受该决定的影响。

- An input archive, the one used when restoring a snapshot, must expose a function call operator with the following signature to load entities:
  输入档案（还原快照时使用的档案）必须公开具有以下签名的函数调用运算符以加载实体：

  ```
  void operator()(entt::entity &);
  ```

  Where `entt::entity` is the type of the entities used by the registry. Each time the function is invoked, the archive must read the next element from the underlying storage and copy it in the given variable.
  Note that all member functions of a loader class make also an initial call to read the *size* of the set they are going to load. In this case, the expected function type for the function call operator is:
  其中`entt::entity`是注册表使用的实体的类型。 每次调用该函数时，存档都必须从基础存储中读取下一个元素，并将其复制到给定的变量中。
  请注意，加载程序类的所有成员函数还会进行一次初始调用，以读取它们将要加载的集合的*size*。 在这种情况下，函数调用运算符的预期函数类型为：

  ```
  void operator()(std::underlying_type_t<entt::entity> &);
  ```

  In addition, the archive must accept a pair of references to an entity and its component for each type to be restored. Therefore, given a type `T`, the archive must contain a function call operator with the following signature:
  此外，对于每种要还原的类型，存档必须接受一对对实体及其组件的引用。 因此，在给定类型为T的情况下，归档文件必须包含具有以下签名的函数调用运算符：

  ```
  void operator()(entt::entity &, T &);
  ```

  Every time such an operator is invoked, the archive must read the next elements from the underlying storage and copy them in the given variables.
  每次调用此类运算符时，归档文件都必须从基础存储中读取下一个元素，并将其复制到给定的变量中。

### One example to rule them all ~~统治所有人的一个例子~~

`EnTT` comes with some examples (actually some tests) that show how to integrate a well known library for serialization as an archive. It uses [`Cereal C++`](https://uscilab.github.io/cereal/) under the hood, mainly because I wanted to learn how it works at the time I was writing the code.
EnTT附带了一些示例（实际上是一些测试），这些示例显示了如何集成众所周知的库以进行序列化以作为存档。 它在后台使用[`Cereal C ++`](https://uscilab.github.io/cereal/)，主要是因为我想在编写代码时学习它的工作原理。

The code is not production-ready and it isn't neither the only nor (probably) the best way to do it. However, feel free to use it at your own risk.
该代码不是为生产准备的，它既不是唯一的，也不是（可能）最好的方法。 但是，随时使用它需要您自担风险。

The basic idea is to store everything in a group of queues in memory, then bring everything back to the registry with different loaders.
基本思想是将所有内容存储在内存中的一组队列中，然后使用不同的加载程序将所有内容带回到注册表中。

# Views and Groups

First of all, it's worth answering a question: why views and groups?
Briefly, they're a good tool to enforce single responsibility. A system that has access to a registry can create and destroy entities, as well as assign and remove components. On the other side, a system that has access to a view or a group can only iterate, read and update entities and components.
It is a subtle difference that can help designing a better software sometimes.
首先，值得回答一个问题：为什么要有视图View和组Groups？
简而言之，它们是执行单一职责的好工具。 有权访问注册表的系统可以创建和销毁实体，以及分配和删除组件。 另一方面，有权访问视图或组的系统只能迭代，读取和更新实体和组件。
这是一个微妙的区别，有时可以帮助设计更好的软件。

More in details:

- Views are a non-intrusive tool to access entities and components without affecting other functionalities or increasing the memory consumption.视图是访问实体和组件而不影响其他功能或不增加内存消耗的非侵入式工具。
- Groups are an intrusive tool that allows to reach higher performance along critical paths but has also a price to pay for that.群组是一种侵入性工具，可以在关键路径上实现更高的性能，但为此付出了代价。

There are mainly two kinds of views: *compile-time* (also known as `view`) and runtime (also known as `runtime_view`).
视图主要有两种：编译时（也称为“视图”）和运行时（也称为“ runtime_view”）。
The former requires a compile-time list of component types and can make several optimizations because of that. The latter can be constructed at runtime instead using numerical type identifiers and are a bit slower to iterate.
前者需要组件类型的编译时列表，因此可以进行一些优化。 后者可以在运行时构造，而不是使用数字类型标识符构造，并且迭代速度稍慢。
In both cases, creating and destroying a view isn't expensive at all since they don't have any type of initialization.
在这两种情况下，创建和销毁视图都不 ~~花钱~~ 昂贵，因为它们没有任何类型的初始化。

Groups come in three different flavors: *full-owning groups*, *partial-owning groups* and *non-owning groups*. The main difference between them is in terms of performance.
群组具有三种不同的口味：*完全拥有所有权的群组*，*部分所有权拥有的群组*和*非拥有的群组*。 它们之间的主要区别在于性能。

Groups can literally *own* one or more component types. They are allowed to rearrange pools so as to speed up iterations. Roughly speaking: the more components a group owns, the faster it is to iterate them.
组实际上可以“拥有”一种或多种组件类型。 允许他们重新排列池，以加快迭代速度。 粗略地说：一个组拥有的组件越多，迭代它们的速度就越快。
A given component can belong to multiple groups only if they are *nested*, so users have to define groups carefully to get the best out of them.
给定的组件仅在“嵌套”时才可以属于多个组，因此用户必须仔细定义组以充分利用它们。

## Views

A view behaves differently if it's constructed for a single component or if it has been created to iterate multiple components. Even the API is slightly different in the two cases.如果视图是为单个组件构造的，或者已创建为迭代多个组件，则该视图的行为会有所不同。 在这两种情况下，甚至API都略有不同。

Single component views are specialized in order to give a boost in terms of performance in all the situations. This kind of views can access the underlying data structures directly and avoid superfluous checks. There is nothing as fast as a single component view. In fact, they walk through a packed array of components and return them one at a time.
单一组件视图经过专门设计，可以在所有情况下提高性能。 这种视图可以直接访问基础数据结构，并避免了多余的检查。 没有什么比单个组件视图快。 实际上，它们遍历打包的组件数组，然后一次返回一个。
Single component views offer a bunch of functionalities to get the number of entities they are going to return and a raw access to the entity list as well as to the component list. It's also possible to ask a view if it contains a given entity.
Refer to the inline documentation for all the details.单个组件视图提供了很多功能来获取它们将要返回的实体的数量，以及对实体列表以及组件列表的原始访问。 也可以询问视图是否包含给定的实体。
有关所有详细信息，请参阅嵌入式文档。

Multi component views iterate entities that have at least all the given components in their bags. During construction, these views look at the number of entities available for each component and pick up a reference to the smallest set of candidates in order to speed up iterations.
多组件视图迭代在其包装袋中至少具有所有给定组件的实体。 在构建期间，这些视图查看每个组件可用的实体数量，并选择对最小候选集的引用，以加快迭代速度。

They offer fewer functionalities than single component views. In particular, a multi component view exposes utility functions to get the estimated number of entities it is going to return and to know whether it's empty or not. It's also possible to ask a view if it contains a given entity.
Refer to the inline documentation for all the details.
它们提供的功能少于单个组件视图。 尤其是，多组件视图公开了实用程序功能，以获取要返回的估计实体数，并了解其是否为空。 也可以询问视图是否包含给定的实体。
有关所有详细信息，请参阅嵌入式文档。

There is no need to store views around for they are extremely cheap to construct, even though they can be copied without problems and reused freely. Views also return newly created and correctly initialized iterators whenever `begin` or `end` are invoked.无需存储视图，因为它们的构造成本非常低，即使可以无问题地复制它们并自由重用它们也是如此。 每当调用`begin`或`end`时，视图还返回新创建并正确初始化的迭代器。

Views share the way they are created by means of a registry:
视图共享通过注册表创建视图的方式：

```
// single component view
auto single = registry.view<position>();

// multi component view
auto multi = registry.view<position, velocity>();

```

Filtering entities by components is also supported:
还支持按组件过滤实体：

```
auto view = registry.view<position, velocity>(entt::exclude<renderable>);
```

To iterate a view, either use it in a range-for loop:
要迭代视图，请在range-for循环中使用它：

```
auto view = registry.view<position, velocity>();

for(auto entity: view) {
    // a component at a time ...
    auto &position = view.get<position>(entity);
    auto &velocity = view.get<velocity>(entity);

    // ... or multiple components at once
    auto [pos, vel] = view.get<position, velocity>(entity);

    // ...
}
```

Or rely on the `each` and `proxy` member functions to iterate both entities and components at once:
或者依靠`each`和`proxy`成员函数一次迭代实体和组件：

```
// through a callback
registry.view<position, velocity>().each([](auto entity, auto &pos, auto &vel) {
    // ...
});

// using an input iterator
for(auto &&[entity, pos, vel]: registry.view<position, velocity>().proxy()) {
    // ...
}
```

Note that entities can also be excluded from the parameter list when received through a callback and this can improve even further the performance during iterations.
请注意，当通过回调接收到实体时，实体也可以从参数列表中排除，这可以进一步提高迭代期间的性能。
Since they aren't explicitly instantiated, empty components aren't returned in any case.
由于未显式实例化它们，因此无论如何都不返回空组件。

There is also a third method for iterating over entities and components for multi component views. It's a chunk based iteration and is made available by means of the `chunked` member function.
还有第三种方法可以迭代多组件视图的实体和组件。 它是基于块的迭代，可通过“块”成员函数使用。

Since this is a particular iteration method with fairly specific purposes, I recommend referring to the official documentation for more details and I won't further investigate the topic here.由于这是一种具有特定用途的特定迭代方法，因此，建议您参考官方文档以了解更多详细信息，在此不再赘述。

As a side note, in the case of single component views, `get` accepts but doesn't strictly require a template parameter, since the type is implicitly defined:
附带说明一下，在单个组件视图的情况下，`get`可以接受但并不严格要求模板参数，因为类型是隐式定义的：

```
auto view = registry.view<const renderable>();

for(auto entity: view) {
    const auto &renderable = view.get(entity);
    // ...
}

```

**Note**: prefer the `get` member function of a view instead of that of a registry during iterations to get the types iterated by the view itself.
**注意**：在迭代过程中，更喜欢视图的“ get”成员函数而不是注册表的“ get”成员函数，以获取由视图本身迭代的类型。

## Runtime views

Runtime views iterate entities that have at least all the given components in their bags. During construction, these views look at the number of entities available for each component and pick up a reference to the smallest set of candidates in order to speed up iterations.
运行时视图会迭代其包中至少包含所有给定组件的实体。 在构建期间，这些视图查看每个组件可用的实体数量，并选择对最小候选集的引用，以加快迭代速度。
They offer more or less the same functionalities of a multi component view. However, they don't expose a `get` member function and users should refer to the registry that generated the view to access components. In particular, a runtime view exposes utility functions to get the estimated number of entities it is going to return and to know whether it's empty or not. It's also possible to ask a runtime view if it contains a given entity.
它们或多或少提供了多组件视图的相同功能。 但是，它们没有公开“ get”成员函数，用户应参考生成视图的注册表来访问组件。 特别是，运行时视图公开了实用程序函数，以获取要返回的估计实体数，并了解其是否为空。 也可以询问运行时视图是否包含给定的实体。
Refer to the inline documentation for all the details.
有关所有详细信息，请参阅嵌入式文档。

Runtime views are pretty cheap to construct and should not be stored around in any case. They should be used immediately after creation and then they should be thrown away. The reasons for this go far beyond the scope of this document.
To iterate a runtime view, either use it in a range-for loop:
运行时视图的构建成本非常低廉，无论如何都不应存储。 创建后应立即使用它们，然后将其丢弃。 这样做的原因远远超出了本文档的范围。
要迭代运行时视图，请在range-for循环中使用它：

```
entt::component types[] = { entt::type_info<position>::id(), entt::type_info<velocity>::id() };
auto view = registry.runtime_view(std::cbegin(types), std::cend(types));

for(auto entity: view) {
    // a component at a time ...
    auto &position = registry.get<position>(entity);
    auto &velocity = registry.get<velocity>(entity);

    // ... or multiple components at once
    auto [pos, vel] = registry.get<position, velocity>(entity);

    // ...
}

```

Or rely on the `each` member function to iterate entities:
或者依靠`each`成员函数来迭代实体：

```
entt::component types[] = { entt::type_info<position>::id(), entt::type_info<velocity>::id() };

registry.runtime_view(std::cbegin(types), std::cend(types)).each([](auto entity) {
    // ...
});
```

Performance are exactly the same in both cases.
两种情况下的性能完全相同。

Filtering entities by components is also supported for this kind of views:
这种视图也支持按组件过滤实体：

```
entt::component components[] = { entt::type_info<position>::id() };
entt::component filter[] = { entt::type_info<velocity>::id() };
auto view = registry.runtime_view(std::cbegin(components), std::cend(components), std::cbegin(filter), std::cend(filter));

```

**Note**: runtime views are meant for all those cases where users don't know at compile-time what components to *use* to iterate entities. If possible, don't use runtime views as their performance are inferior to those of the other views.
**注意**：运行时视图用于所有在编译时用户不知道要使用哪些组件来迭代实体的情况。 如果可能的话，请不要使用运行时视图，因为它们的性能不如其他视图。

## Groups

Groups are meant to iterate multiple components at once and to offer a faster alternative to multi component views.
组旨在一次迭代多个组件，并为多组件视图提供更快的替代方法。
Groups overcome the performance of the other tools available but require to get the ownership of components and this sets some constraints on pools. On the other side, groups aren't an automatism that increases memory consumption, affects functionalities and tries to optimize iterations for all the possible combinations of components. Users can decide when to pay for groups and to what extent.
组克服了其他可用工具的性能，但需要获得组件的所有权，这对池设置了一些约束。 另一方面，组并不是增加内存消耗，影响功能并尝试针对组件的所有可能组合优化迭代的自动机制。 用户可以决定何时为团体付费以及在什么程度上付费。
The most interesting aspect of groups is that they fit *usage patterns*. Other solutions around usually try to optimize everything, because it is known that somewhere within the *everything* there are also our usage patterns. However this has a cost that isn't negligible, both in terms of performance and memory usage. Ironically, users pay the price also for things they don't want and this isn't something I like much. Even worse, one cannot easily disable such a behavior. Groups work differently instead and are designed to optimize only the real use cases when users find they need to.
分组最有趣的方面是它们适合*使用模式*。 周围的其他解决方案通常会尝试优化所有内容，因为众所周知，“所有内容”中的某处也存在我们的使用模式。 但是，就性能和内存使用而言，这是不可忽略的成本。 具有讽刺意味的是，用户也为不需要的东西付出了代价，而这并不是我最喜欢的东西。 更糟糕的是，人们无法轻易禁用这种行为。 组的工作方式有所不同，并且旨在仅在用户发现需要时才对实际用例进行优化。
Another nice-to-have feature of groups is that they have no impact on memory consumption, put aside full non-owning groups that are pretty rare and should be avoided as long as possible.
组的另一个不错的功能是它们对内存消耗没有影响，将完全很少的非所有权组放在一旁，这是非常少见的，应尽可能避免使用。

All groups affect to an extent the creation and destruction of their components. This is due to the fact that they must *observe* changes in the pools of interest and arrange data *correctly* when needed for the types they own.所有群体都会在一定程度上影响其组件的创建和销毁。 这是由于这样的事实，即它们必须*观察*感兴趣的池中的更改，并在需要时*正确*安排其拥有的类型的数据。
That being said, the way groups operate is beyond the scope of this document. However, it's unlikely that users will be able to appreciate the impact of groups on the other functionalities of a registry.话虽如此，团体的运作方式不在本文件范围之内。 但是，用户不太可能能够理解组对注册表其他功能的影响。

Groups offer a bunch of functionalities to get the number of entities they are going to return and a raw access to the entity list as well as to the component list for owned components. It's also possible to ask a group if it contains a given entity.组提供了很多功能来获取将要返回的实体的数量，以及对实体列表以及所拥有组件的组件列表的原始访问。 也可以询问组是否包含给定的实体。
Refer to the inline documentation for all the details.有关所有详细信息，请参阅嵌入式文档。

There is no need to store groups around for they are extremely cheap to construct, even though they can be copied without problems and reused freely. A group performs an initialization step the very first time it's requested and this could be quite costly. To avoid it, consider creating the group when no components have been assigned yet. If the registry is empty, preparation is extremely fast. Groups also return newly created and correctly initialized iterators whenever `begin` or `end` are invoked.
无需存储组，因为它们的构造成本非常低廉，即使可以毫无问题地复制它们并自由重用它们。 组在第一次请求时执行初始化步骤，这可能会非常昂贵。 为避免这种情况，请考虑在尚未分配任何组件时创建组。 如果注册表为空，则准备工作非常快。 每当调用“ begin”或“ end”时，组也会返回新创建并正确初始化的迭代器。

To iterate groups, either use them in a range-for loop:要迭代组，请在range-for循环中使用它们：

```
auto group = registry.group<position>(entt::get<velocity>);

for(auto entity: group) {
    // a component at a time ...
    auto &position = group.get<position>(entity);
    auto &velocity = group.get<velocity>(entity);

    // ... or multiple components at once
    auto [pos, vel] = group.get<position, velocity>(entity);

    // ...
}
```

Or rely on the `each` and `proxy` member functions to iterate both entities and components at once:
或者依靠`each`和`proxy`成员函数一次迭代实体和组件：

```
// through a callback
registry.group<position>(entt::get<velocity>).each([](auto entity, auto &pos, auto &vel) {
    // ...
});

// using an input iterator
for(auto &&[entity, pos, vel]: registry.group<position>(entt::get<velocity>).proxy()) {
    // ...
}
```

Note that entities can also be excluded from the parameter list when received through a callback and this can improve even further the performance during iterations.请注意，当通过回调接收到实体时，实体也可以从参数列表中排除，这可以进一步提高迭代期间的性能。
Since they aren't explicitly instantiated, empty components aren't returned in any case.由于未显式实例化它们，因此无论如何都不返回空组件。

**Note**: prefer the `get` member function of a group instead of that of a registry during iterations to get the types iterated by the group itself.
**注意**：在迭代过程中，最好使用组的get函数而不是注册表的get函数来获取由组本身迭代的类型。

### Full-owning groups完全所有权组

A full-owning group is the fastest tool an user can expect to use to iterate multiple components at once. It iterates all the components directly, no indirection required. This type of groups performs more or less as if users are accessing sequentially a bunch of packed arrays of components all sorted identically, with no jumps nor branches.
拥有所有权的组是用户期望一次迭代多个组件的最快工具。 它直接迭代所有组件，而无需间接调用。 这种类型的组或多或少地表现得好似用户正在顺序访问一堆打包的组件数组，这些组件的排序完全相同，没有跳转或分支。

A full-owning group is created as:拥有所有权的组的创建方式为：

```
auto group = registry.group<position, velocity>();
```

Filtering entities by components is also supported:还支持按组件过滤实体：

```
auto group = registry.group<position, velocity>(entt::exclude<renderable>);
```

Once created, the group gets the ownership of all the components specified in the template parameter list and arranges their pools as needed.创建后，组将获得模板参数列表中指定的所有组件的所有权，并根据需要排列其池。

Sorting owned components is no longer allowed once the group has been created. However, full-owning groups can be sorted by means of their `sort` member functions. Sorting a full-owning group affects all its instances.创建组后，将不再允许对拥有的组件进行排序。 但是，完全拥有的组可以通过它们的`sort`成员函数进行分类。 对完全拥有的组进行排序会影响其所有实例。

### Partial-owning groups

A partial-owning group works similarly to a full-owning group for the components it owns, but relies on indirection to get components owned by other groups. This isn't as fast as a full-owning group, but it's already much faster than views when there are only one or two free components to retrieve (the most common cases likely). In the worst case, it's not slower than views anyway.
部分拥有者组对其拥有的组件的工作方式与完全拥有者组类似，但是依赖于间接获取其他组拥有的组件。 这没有一个完全拥有的组快，但是在只有一个或两个免费组件可检索的情况下（可能是最常见的情况），它已经比视图快得多。 在最坏的情况下，它并不比视图慢。

A partial-owning group is created as:
创建部分拥有权的组是：

```
auto group = registry.group<position>(entt::get<velocity>);
```

Filtering entities by components is also supported:
还支持按组件过滤实体：

```
auto group = registry.group<position>(entt::get<velocity>, entt::exclude<renderable>);
```

Once created, the group gets the ownership of all the components specified in the template parameter list and arranges their pools as needed. The ownership of the types provided via `entt::get` doesn't pass to the group instead.
创建后，组将获得模板参数列表中指定的所有组件的所有权，并根据需要排列其池。 通过`entt::get`提供的类型的所有权不会传递给该组。

Sorting owned components is no longer allowed once the group has been created. However, partial-owning groups can be sorted by means of their `sort` member functions. Sorting a partial-owning group affects all its instances.
创建组后，将不再允许对拥有的组件进行排序。 但是，部分拥有者组可以通过其`sort`成员函数进行分类。 对部分拥有者的组进行排序会影响其所有实例。

### Non-owning groups

Non-owning groups are usually fast enough, for sure faster than views and well suited for most of the cases. However, they require custom data structures to work properly and they increase memory consumption. As a rule of thumb, users should avoid using non-owning groups, if possible.非所有者组通常足够快，可以肯定比视图快，并且非常适合大多数情况。 但是，它们需要自定义数据结构才能正常工作，并且会增加内存消耗。 根据经验，如果可能，用户应避免使用非所有者组。

A non-owning group is created as:创建非所有者组的方式如下：

```
auto group = registry.group<>(entt::get<position, velocity>);
```

Filtering entities by components is also supported:还支持按组件过滤实体：

```
auto group = registry.group<>(entt::get<position, velocity>, entt::exclude<renderable>);
```

The group doesn't receive the ownership of any type of component in this case. This type of groups is therefore the least performing in general, but also the only one that can be used in any situation to slightly improve performance.在这种情况下，该组不会获得任何类型的组件的所有权。 因此，这种类型的组通常是性能最低的组，但也是在任何情况下都可以用来稍微提高性能的唯一组。

Non-owning groups can be sorted by means of their `sort` member functions. Sorting a non-owning group affects all its instances.非所有者组可以通过它们的`sort`成员函数进行分类。 对非所有者组进行排序会影响其所有实例。

### Nested groups 嵌套组

A type of component cannot be owned by two or more conflicting groups such as:一种组件类型不能被两个或多个冲突组所拥有，例如：

- `registry.group<transform, sprite>()`.
- `registry.group<transform, rotation>()`.

However, the same type can be owned by groups belonging to the same *family*, also called *nested groups*, such as:
但是，属于同一“家庭”的组（也称为“嵌套组”）可以拥有相同的类型，例如：

- `registry.group<sprite, transform>()`.
- `registry.group<sprite, transform, rotation>()`.

Fortunately, these are also very common cases if not the most common ones.
It allows to increase performance on a greater number of component combinations.
幸运的是，即使不是最常见的情况，这些也是非常常见的情况。
它允许在更多数量的组件组合上提高性能。

Two nested groups are such that they own at least one componet type and the list of component types involved by one of them is contained entirely in that of the other. More specifically, this applies independently to all component lists used to define a group.
两个嵌套的组使得它们拥有至少一个组件类型，并且其中一个组件所涉及的组件类型列表完全包含在另一个组件中。 更具体地说，这独立地应用于用于定义组的所有组件列表。
Therefore, the rules for defining whether two or more groups are nested can be summarized as:
因此，用于定义是否嵌套两个或更多组的规则可以概括为：

- One of the groups involves one or more additional component types with respect to the other, whether they are owned, observed or excluded.
  组中的一个相对于另一组涉及一个或多个其他组件类型，无论它们是拥有，观察到的还是排除在外的。
- The list of component types owned by the most restrictive group is the same or contains entirely that of the others. This also applies to the list of observed and excluded components.
  限制性最强的组拥有的组件类型列表相同或完全包含其他组件类型。 这也适用于观察和排除的组件列表。

It means that nested groups *extend* their parents by adding more conditions in the form of new components.
这意味着嵌套组通过以新组件的形式添加更多条件来扩展其父级。

As mentioned, the components don't necessarily have to be all *owned* so that two groups can be considered nested. The following definitions are fully valid:
如前所述，组件不一定必须全部拥有，以便可以将两个组视为嵌套的。 以下定义是完全有效的：

- `registry.group<sprite>(entt::get<renderable>)`.
- `registry.group<sprite, transform>(entt::get<renderable>)`.
- `registry.group<sprite, transform>(entt::get<renderable, rotation>)`.

Exclusion lists also play their part in this respect. When it comes to defining nested groups, an excluded component type `T` is treated as being an observed type `not_T`. Therefore, consider these two definitions:
排除列表在这方面也发挥了作用。 在定义嵌套组时，排除的组件类型 `T`被视为观察到的类型`not_T`。 因此，请考虑以下两个定义：

- `registry.group<sprite, transform>()`.
- `registry.group<sprite, transform>(entt::exclude<rotation>)`.

They are treated as if users were defining the following groups:
将它们视为用户正在定义以下组：

- `group<sprite, transform>()`.
- `group<sprite, transform>(entt::get<not_rotation>)`.

Where `not_rotation` is an empty tag present only when `rotation` is not.
其中“ not_rotation”是一个空标签，仅当“ rotation”不存在时才存在。

Because of this, to define a new group that is more restrictive than an existing one, it's enough to take the list of component types of the latter and extend it by adding new component types either owned, observed or excluded, without any precautions depending on the case.
因此，要定义一个比现有限制更严格的新组，只需获取后者的组件类型列表，然后通过添加新的拥有，观察或排除的组件类型来扩展它，而无需采取任何预防措施，具体取决于 案子。

The opposite is also true. To define a *larger* group, it will be enough to take an existing one and remove *constraints* from it, in whatever form they are expressed.
Note that the greater the number of component types involved by a group, the more restrictive it is.
反之亦然。 要定义一个“更大”的组，只需以一个现有的组并以任何形式将“约束”从中删除就可以了。
请注意，一个组所涉及的组件类型越多，限制就越大。

Despite the extreme flexibility of nested groups which allow to independently use component types either owned, observed or excluded, the real strength of this tool lies in the possibility of defining a greater number of groups that **own** the same components, thus offering the best performance in more cases.
尽管嵌套组具有极大的灵活性，它允许独立使用拥有，观察或排除的组件类型，但此工具的真正优势在于可以定义“拥有”相同组件的更多组，从而提供 在更多情况下表现最佳。
In fact, given a list of component types involved by a group, the greater the number of those owned, the greater the performance of the group itself.
实际上，给定组所涉及的组件类型的列表，所拥有的组件数量越多，组本身的性能就越高。

As a side note, it's no longer possible to sort all groups when defining nested ones. This is because the most restrictive group shares its elements with the less restrictive ones and ordering the latter would invalidate the former.
However, given a family of nested groups, it's still possible to sort the most restrictive of them. To prevent users from having to remember which of their groups is the most restrictive, the registry class offers the `sortable` member function to know if a group can be sorted or not.
附带说明一下，在定义嵌套分组时，不再可能对所有分组进行排序。 这是因为限制最大的组与限制较小的组共享其元素，而命令后者将使前者无效。
但是，给定一个嵌套组的族，仍然可以对限制性最大的组进行排序。 为了避免用户必须记住其组中限制最大的组，注册表类提供了“ sortable”成员函数，以了解是否可以对组进行排序。

## Types: const, non-const and all in between

The `registry` class offers two overloads when it comes to constructing views and groups: a const version and a non-const one. The former accepts both const and non-const types as template parameters, the latter accepts only const types instead.
registry类在构造视图和组时提供了两个重载：一个const版本和一个非const版本。 前者将const和非const类型都接受为模板参数，而后者仅接受const类型。

It means that views and groups can be constructed from a const registry and they propagate the constness of the registry to the types involved. As an example:

```
entt::view<const position, const velocity> view = std::as_const(registry).view<const position, const velocity>();

```

Consider the following definition for a non-const view instead:

```
entt::view<position, const velocity> view = registry.view<position, const velocity>();

```

In the example above, `view` can be used to access either read-only or writable `position` components while `velocity` components are read-only in all cases.
Similarly, these statements are all valid:

```
position &pos = view.get<position>(entity);
const position &cpos = view.get<const position>(entity);
const velocity &cpos = view.get<const velocity>(entity);
std::tuple<position &, const velocity &> tup = view.get<position, const velocity>(entity);
std::tuple<const position &, const velocity &> ctup = view.get<const position, const velocity>(entity);

```

It's not possible to get non-const references to `velocity` components from the same view instead and these will result in compilation errors:

```
velocity &cpos = view.get<velocity>(entity);
std::tuple<position &, velocity &> tup = view.get<position, velocity>(entity);
std::tuple<const position &, velocity &> ctup = view.get<const position, velocity>(entity);

```

The `each` member functions also propagates constness to its *return values*:

```
view.each([](auto entity, position &pos, const velocity &vel) {
    // ...
});

```

A caller can still refer to the `position` components through a const reference because of the rules of the language that fortunately already allow it.

The same concepts apply to groups as well.

## Give me everything

Views and groups are narrow windows on the entire list of entities. They work by filtering entities according to their components.
In some cases there may be the need to iterate all the entities still in use regardless of their components. The registry offers a specific member function to do that:

```
registry.each([](auto entity) {
    // ...
});

```

It returns to the caller all the entities that are still in use.
As a rule of thumb, consider using a view or a group if the goal is to iterate entities that have a determinate set of components. These tools are usually much faster than combining this function with a bunch of custom tests.
In all the other cases, this is the way to go.

There exists also another member function to use to retrieve orphans. An orphan is an entity that is still in use and has no assigned components.
The signature of the function is the same of `each`:

```
registry.orphans([](auto entity) {
    // ...
});

```

To test the *orphanity* of a single entity, use the member function `orphan` instead. It accepts a valid entity identifer as an argument and returns true in case the entity is an orphan, false otherwise.

In general, all these functions can result in poor performance.
`each` is fairly slow because of some checks it performs on each and every entity. For similar reasons, `orphans` can be even slower. Both functions should not be used frequently to avoid the risk of a performance hit.

## What is allowed and what is not

Most of the *ECS* available out there don't allow to create and destroy entities and components during iterations.
`EnTT` partially solves the problem with a few limitations:

- Creating entities and components is allowed during iterations in most cases.
- Deleting the current entity or removing its components is allowed during iterations. For all the other entities, destroying them or removing their components isn't allowed and can result in undefined behavior.

In these cases, iterators aren't invalidated. To be clear, it doesn't mean that also references will continue to be valid.
Consider the following example:

```
registry.view<position>([&](const auto entity, auto &pos) {
    registry.emplace<position>(registry.create(), 0., 0.);
    pos.x = 0.; // warning: dangling pointer
});

```

The `each` member function won't break (because iterators aren't invalidated) but there are no guarantees on references. Use a common range-for loop and get components directly from the view or move the creation of components at the end of the function to avoid dangling pointers.

Iterators are invalidated instead and the behavior is undefined if an entity is modified or destroyed and it's not the one currently returned by the iterator nor a newly created one.
To work around it, possible approaches are:

- Store aside the entities and the components to be removed and perform the operations at the end of the iteration.
- Mark entities and components with a proper tag component that indicates they must be purged, then perform a second iteration to clean them up one by one.

A notable side effect of this feature is that the number of required allocations is further reduced in most of the cases.

### More performance, more constraints

Groups are a (much) faster alternative to views. However, the higher the performance, the greater the constraints on what is allowed and what is not.
In particular, groups add in some rare cases a limitation on the creation of components during iterations. It happens in quite particular cases. Given the nature and the scope of the groups, it isn't something in which it will happen to come across probably, but it's good to know it anyway.

First of all, it must be said that creating components while iterating a group isn't a problem at all and can be done freely as it happens with the views. The same applies to the destruction of components and entities, for which the rules mentioned above apply.

The additional limitation pops out instead when a given component that is owned by a group is iterated outside of it. In this case, adding components that are part of the group itself may invalidate the iterators. There are no further limitations to the destruction of components and entities.
Fortunately, this isn't always true. In fact, it almost never is and this happens only under certain conditions. In particular:

- Iterating a type of component that is part of a group with a single component view and adding to an entity all the components required to get it into the group may invalidate the iterators.
- Iterating a type of component that is part of a group with a multi component view and adding to an entity all the components required to get it into the group can invalidate the iterators, unless users specify another type of component to use to induce the order of iteration of the view (in this case, the former is treated as a free type and isn't affected by the limitation).

In other words, the limitation doesn't exist as long as a type is treated as a free type (as an example with multi component views and partial- or non-owning groups) or iterated with its own group, but it can occur if the type is used as a main type to rule on an iteration.
This happens because groups own the pools of their components and organize the data internally to maximize performance. Because of that, full consistency for owned components is guaranteed only when they are iterated as part of their groups or as free types with multi component views and groups in general.

# Empty type optimization

An empty type `T` is such that `std::is_empty_v<T>` returns true. They are also the same types for which *empty base optimization* (EBO) is possibile.
`EnTT` handles these types in a special way, optimizing both in terms of performance and memory usage. However, this also has consequences that are worth mentioning.

When an empty type is detected, it's not instantiated in any case. Therefore, only the entities to which it's assigned are made available.
There doesn't exist a way to *iterate* empty types. Views and groups will never return instances of empty types (for example, during a call to `each`) and some functions such as `try_get` or the raw access to the list of components aren't available for them. Finally, the `sort` functionality accepts only callbacks that require to return entities rather than components:

```
registry.sort<empty_type>([](const entt::entity lhs, const entt::entity rhs) {
    return entt::registry::entity(lhs) < entt::registry::entity(rhs);
});

```

On the other hand, iterations are faster because only the entities to which the type is assigned are considered. Moreover, less memory is used, mainly because there doesn't exist any instance of the component, no matter how many entities it is assigned to.

More in general, none of the features offered by the library is affected, but for the ones that require to return actual instances.
This optimization can be disabled by defining the `ENTT_NO_ETO` macro. In this case, empty types will be treated like all other types, no matter what.

# Multithreading

In general, the entire registry isn't thread safe as it is. Thread safety isn't something that users should want out of the box for several reasons. Just to mention one of them: performance.
Views, groups and consequently the approach adopted by `EnTT` are the great exception to the rule. It's true that views, groups and iterators in general aren't thread safe by themselves. Because of this users shouldn't try to iterate a set of components and modify the same set concurrently. However:

- As long as a thread iterates the entities that have the component `X` or assign and removes that component from a set of entities, another thread can safely do the same with components `Y` and `Z` and everything will work like a charm. As a trivial example, users can freely execute the rendering system and iterate the renderable entities while updating a physic component concurrently on a separate thread.
- Similarly, a single set of components can be iterated by multiple threads as long as the components are neither assigned nor removed in the meantime. In other words, a hypothetical movement system can start multiple threads, each of which will access the components that carry information about velocity and position for its entities.

This kind of entity-component systems can be used in single threaded applications as well as along with async stuff or multiple threads. Moreover, typical thread based models for *ECS* don't require a fully thread safe registry to work. Actually, users can reach the goal with the registry as it is while working with most of the common models.

Because of the few reasons mentioned above and many others not mentioned, users are completely responsible for synchronization whether required. On the other hand, they could get away with it without having to resort to particular expedients.

## Iterators

A special mention is needed for the iterators returned by views and groups. Most of the times they meet the requirements of random access iterators, in all cases they meet at least the requirements of bidirectional iterators.
In other terms, they are suitable for use with the parallel algorithms of the standard library. If it's not clear, this is a great thing.

As an example, this kind of iterators can be used in combination with `std::for_each` and `std::execution::par` to parallelize the visit and therefore the update of the components returned by a view or a group, as long as the constraints previously discussed are respected:

```
auto view = registry.view<position, const velocity>();

std::for_each(std::execution::par_unseq, view.begin(), view.end(), [&view](auto entity) {
    // ...
});

```

This can increase the throughput considerably, even without resorting to who knows what artifacts that are difficult to maintain over time.

Unfortunately, because of the limitations of the current revision of the standard, the parallel `std::for_each` accepts only forward iterators. This means that the iterators provided by the library cannot return proxy objects as references and **must** return actual reference types instead.
This may change in the future and the iterators will almost certainly return both the entities and a list of references to their components sooner or later. Multi-pass guarantee won't break in any case and the performance should even benefit from it further.

# Beyond this document

There are many other features and functions not listed in this document.
`EnTT` and in particular its ECS part is in continuous development and some things could be forgotten, others could have been omitted on purpose to reduce the size of this file. Unfortunately, some parts may even be outdated and still to be updated.

For further information, it's recommended to refer to the documentation included in the code itself or join the official channels to ask a question.