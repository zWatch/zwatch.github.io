# Crash Course: cooperative scheduler



Michele Caini edited this page on 3 Feb · [4 revisions](https://github.com/skypjack/entt/wiki/Crash-Course:-cooperative-scheduler/_history)

# Crash Course: cooperative scheduler

协作调度器

# Table of Contents

- [Introduction](#introduction)
- [The process](The-process)
  - [Adaptor](#adaptor)
- [The scheduler](#the-scheduler)

# Introduction

Sometimes processes are a useful tool to work around the strict definition of a system and introduce logic in a different way, usually without resorting to the introduction of other components.
有时，流程是解决严格定义系统并以不同方式引入逻辑的有用工具，通常无需诉诸其他组件。

`EnTT` offers a minimal support to this paradigm by introducing a few classes that users can use to define and execute cooperative processes.
EnTT通过引入一些用户可以用来定义和执行协作过程的类，为这种范例提供了最小的支持。

# The process

A typical process must inherit from the `process` class template that stays true to the CRTP idiom. Moreover, derived classes must specify what's the intended type for elapsed times.
一个典型的流程必须继承自`process`类模板，该模板对CRTP习惯用法保持真实。 此外，派生类必须指定经过时间的预期类型是什么。

A process should expose publicly the following member functions whether required (note that it isn't required to define a function unless the derived class wants to *override* the default behavior):
进程是否应公开公开以下成员函数（请注意，除非派生类想要*覆盖*默认行为，否则不需要定义函数）：

- `void update(Delta, void *);`

  It's invoked once per tick until a process is explicitly aborted or it terminates either with or without errors. Even though it's not mandatory to declare this member function, as a rule of thumb each process should at least define it to work properly. The `void *` parameter is an opaque pointer to user data (if any) forwarded directly to the process during an update.
  它每个滴答调用一次，直到显式中止一个进程或它终止（无论有无错误）。 即使不是强制要求声明此成员函数，但根据经验，每个进程都至少应定义它才能正常工作。 “ void *”参数是指向用户数据（如果有的话）的不透明指针，用户数据在更新过程中直接转发给进程。

- `void init();`

  It's invoked when the process joins the running queue of a scheduler. This happens as soon as it's attached to the scheduler if the process is a top level one, otherwise when it replaces its parent if the process is a continuation.
  当进程加入调度程序的运行队列时调用它。 如果进程是顶级进程，则在将其附加到调度程序后立即发生；否则，如果进程是继续进程，则在替换其父进程时发生。

- `void succeeded();`

  It's invoked in case of success, immediately after an update and during the same tick.
  在成功的情况下，在更新之后和同一滴答中立即调用它。

- `void failed();`

  It's invoked in case of errors, immediately after an update and during the same tick.
  如果发生错误，则在更新之后和同一滴答中立即调用它。

- `void aborted();`

  It's invoked only if a process is explicitly aborted. There is no guarantee that it executes in the same tick, this depends solely on whether the process is aborted immediately or not.
  仅当显式中止进程时才调用它。 无法保证它在同一滴答中执行，这仅取决于该过程是否立即中止。

Derived classes can also change the internal state of a process by invoking `succeed` and `fail`, as well as `pause` and `unpause` the process itself. All these are protected member functions made available to be able to manage the life cycle of a process from a derived class.
派生类还可以通过调用“成功”和“失败”，以及“暂停”和“取消暂停”流程本身来更改流程的内部状态。 所有这些都是受保护的成员函数，可用来从派生类管理进程的生命周期。

Here is a minimal example for the sake of curiosity:
为了好奇，下面是一个最小的示例：

```cpp
struct my_process: entt::process<my_process, std::uint32_t> {
    using delta_type = std::uint32_t;
    my_process(delta_type delay)
        : remaining{delay}
    {}
    void update(delta_type delta, void *) {
        remaining -= std::min(remaining, delta);
        // ...
        if(!remaining) {
            succeed();
        }
    }
private:
    delta_type remaining;
};
```

## Adaptor

Lambdas and functors can't be used directly with a scheduler for they are not properly defined processes with managed life cycles.
Lambda和函子不能直接与调度程序一起使用，因为它们不是具有托管生命周期的正确定义的过程。

This class helps in filling the gap and turning lambdas and functors into full featured processes usable by a scheduler.
此类有助于填补空白，并将lambda和函子转换为可由调度程序使用的功能齐全的进程。

The function call operator has a signature similar to the one of the `update` function of a process but for the fact that it receives two extra arguments to call whenever a process is terminated with success or with an error:
函数调用操作符的签名类似于进程的“更新”函数的签名，但事实是，只要进程成功或错误终止，它都会收到两个额外的参数来调用：

```cpp
void(Delta delta, void *data, auto succeed, auto fail);
```

Parameters have the following meaning:
参数含义如下：

- `delta` is the elapsed time.
- `data` is an opaque pointer to user data if any, `nullptr` otherwise.
- `succeed` is a function to call when a process terminates with success.
- `fail` is a function to call when a process terminates with errors.

Both `succeed` and `fail` accept no parameters at all.

Note that usually users shouldn't worry about creating adaptors at all. A scheduler creates them internally each and every time a lambda or a functor is used as a process.

# The scheduler

A cooperative scheduler runs different processes and helps managing their life cycles.

Each process is invoked once per tick. If it terminates, it's removed automatically from the scheduler and it's never invoked again. Otherwise it's a good candidate to run one more time the next tick.
A process can also have a child. In this case, the parent process is replaced with its child when it terminates and only if it returns with success. In case of errors, both the parent process and its child are discarded. This way, it's easy to create chain of processes to run sequentially.

Using a scheduler is straightforward. To create it, users must provide only the type for the elapsed times and no arguments at all:

```cpp
entt::scheduler<std::uint32_t> scheduler;
```

It has member functions to query its internal data structures, like `empty` or `size`, as well as a `clear` utility to reset it to a clean state:

```cpp
// checks if there are processes still running
const auto empty = scheduler.empty();

// gets the number of processes still running
entt::scheduler<std::uint32_t>::size_type size = scheduler.size();

// resets the scheduler to its initial state and discards all the processes
scheduler.clear();
```

To attach a process to a scheduler there are mainly two ways:

- If the process inherits from the `process` class template, it's enough to indicate its type and submit all the parameters required to construct it to the `attach` member function:

  ```cpp
  scheduler.attach<my_process>(1000u);
  ```

- Otherwise, in case of a lambda or a functor, it's enough to provide an instance of the class to the `attach` member function:

  ```cpp
  scheduler.attach([](auto...){ /* ... */ });
  ```

In both cases, the return value is an opaque object that offers a `then` member function to use to create chains of processes to run sequentially.
As a minimal example of use:

```cpp
// schedules a task in the form of a lambda function
scheduler.attach([](auto delta, void *, auto succeed, auto fail) {
    // ...
})
// appends a child in the form of another lambda function
.then([](auto delta, void *, auto succeed, auto fail) {
    // ...
})
// appends a child in the form of a process class
.then<my_process>(1000u);
```

To update a scheduler and therefore all its processes, the `update` member function is the way to go:

```cpp
// updates all the processes, no user data are provided
scheduler.update(delta);

// updates all the processes and provides them with custom data
scheduler.update(delta, &data);
```

In addition to these functions, the scheduler offers an `abort` member function that can be used to discard all the running processes at once:

```cpp
// aborts all the processes abruptly ...
scheduler.abort(true);

// ... or gracefully during the next tick
scheduler.abort();
```