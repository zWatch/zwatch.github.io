## 智能指针



|            | in                                                           | out                                                          |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| shared_ptr | 函数内（或类成员函数内）可能保留该共享指针                   | 你可以保留共享该指针（通常给出该参数的一方会保留该指针，如果不保留，考虑使用unique_ptr） |
| weak_ptr   | 函数内部可能对指针引用的对象进行copy，或者只是短暂的引用，不会共享该指针 | 你不应该共享该指针，可以暂时使用（转换成shared_ptr），或者对其引用进行copy |
| unique_ptr | 你必须放弃该指针的所有权（std::move）                        | 你获得了该指针的所有权                                       |
|            |                                                              |                                                              |
| temp_ptr   | 临时使用，可以修改对象但不能保留该指针                       | 你可以临时使用，可以修改对象不能保留该指针                   |
| copy_ptr   | 函数内会对其进行拷贝，不保留该指针，也不会修改               | 你可以对其进行拷贝，不能保留该指针                           |

smart_ptr\<const _Tx\> 代表不会修改引用的对象，只是拿来做查询。



考虑到语义标识，可以考虑对类型进行重载，添加

```c++
template<Tx, Dx>
using temp_ptr = weak_ptr<Tx, Dx>; //或者shared_ptr，以减少一次转换，但是重载时会遇到问题(语义似乎有些重复，毕竟有smart_ptr<const _Tx>)，但是要做修改的时候可能会用到

template<Tx, Dx>
using copy_ptr = weak_ptr<Tx, Dx>;

//事实上copy_ptr语义也是不需要的，因为可以再内部copy，然后返回unique_ptr
//但考虑到可能对引用对象的拷贝可能需要特殊化的逻辑，这个也是有意义的
```

如果再考虑多线程的情况，可以对上述指针进行封装，添加锁结构等

可以考虑规定不允许返回裸指针，必须使用智能指针。



**q:使用了其他生命管理周期的指针(第三方库定义的智能指针)该如何转换成shared_ptr**

a:将共享指针的删除函数置为空，这样在共享指针析构时 不会析构引用的对象

```c++
int local_int = 12;
std::shared_ptr<int> s_local(&local_int, [](int*) {});
或者直接定义
auto null_delete=
[](auto ptr)
{
	//empty
}
std::shared_ptr<int> s2_local(&local_int, null_delete);

//例子2
Ptr<MgFeatureService> fetuSvc = serviceMgr->create(...);

std::unique_ptr<int> spFetuSvc(
                    (MgFeatureService*)(featSvc)
                    , null_delete);


```



## 带锁的指针(未验证)

```c++
struct mutex_shared_ptr : std::shared_ptr //这里是私有继承
{
	std::shared_ptr<std::mutex> mutex; //指向同一个对象
public:
	void lock();
    bool try_lock();
    void unlock();
//...和一些从std::shared_ptr抄的函数。   
//原则时赋值时，两者要使用同一mutex
//debug时可以在unlock函数中check一下use_count()和mutex->use_count()
}
```

1.必须符合

## 原始指针

一般不要返回原始指针，如果必须要使用原始指针 （比如在模块导出函数的情况下）

```c++
typedef xxx* ownRawPtr_xxx;
///同unique_ptr,做参数做返回值都代表所有权转移，
typedef xxx* tmpRawPtr_xxx;
///做参数做返回值都代表所有权不会发生转移，更不会发生释放等，会修改或拷贝
```

不同的是，这里没有引用计数，所以最好不要共享指针，除非能非常明确的确认变量的生存周期与所有权的转移。

